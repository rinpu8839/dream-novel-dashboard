completed: false
};
currentDate = new Date(currentDate.getTime() + template.duration * 24 * 60 * 60 * 1000);
return task;
});
}

// ã‚¿ã‚¹ã‚¯è¡¨ç¤º
function renderTasks() {
const taskList = document.getElementById('taskList');
taskList.innerHTML = '';

Object.entries(tasks).forEach(([genre, genreTasks]) => {
if (selectedGenre !== 'å…¨ä½“' && selectedGenre !== genre) return;

const genreSection = document.createElement('div');
genreSection.innerHTML = `
<div style="display: flex; justify-content: space-between; align-items: center; margin: 15px 0;">
<h3 style="color: white;">${genre}</h3>
<button class="btn btn-success btn-small" onclick="showAddTaskModal('${genre}')">
+ ã‚¿ã‚¹ã‚¯è¿½åŠ 
</button>
</div>
`;

genreTasks.forEach(task => {
const taskCard = createTaskCard(task);
genreSection.appendChild(taskCard);
});

taskList.appendChild(genreSection);
});
}

// ã‚¿ã‚¹ã‚¯ã‚«ãƒ¼ãƒ‰ä½œæˆ
function createTaskCard(task) {
const card = document.createElement('div');
const isOverdue = new Date(task.endDate) < new Date() && !task.completed;
card.className = `task-card ${task.completed ? 'completed' : ''} ${isOverdue ? 'overdue' : ''}`;

const deadlineClass = getDeadlineClass(task.endDate);
const deadlineText = new Date(task.endDate).toLocaleDateString('ja-JP');

card.innerHTML = `
<div class="task-header">
    <!-- ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ãƒ»å¾©å…ƒãƒœã‚¿ãƒ³ -->
<div style="margin-top: 15px; display: flex; gap: 10px; flex-wrap: wrap;">
    <button class="btn btn-warning" onclick="exportBackup()">
        ğŸ’¾ ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ä¿å­˜
    </button>
    <button class="btn btn-success" onclick="importBackup()">
        ğŸ“‚ ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—èª­è¾¼
    </button>
    <div style="font-size: 12px; color: #666; width: 100%; margin-top: 5px;">
        â€» å®šæœŸçš„ã«ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã‚’å–ã‚‹ã“ã¨ã‚’ãŠå‹§ã‚ã—ã¾ã™
    </div>
</div>
<div style="display: flex; align-items: center; flex: 1;">
<input type="checkbox" class="checkbox" ${task.completed ? 'checked' : ''}
onchange="toggleTask('${task.id}')">
<div class="task-title" onclick="showTaskDetail('${task.id}')">${task.title}</div>
</div>
<div style="display: flex; align-items: center; gap: 10px;">
<div class="task-deadline ${deadlineClass}">${deadlineText}</div>
<div class="task-actions">
<button class="btn btn-danger btn-small" onclick="deleteTask('${task.id}')">å‰Šé™¤</button>
</div>
</div>
</div>
<div style="font-size: 12px; color: #666; margin: 5px 0;">${task.details}</div>
<div class="progress-bar">
<div class="progress-fill" style="width: ${task.progress}%"></div>
</div>
<div style="display: flex; justify-content: space-between; align-items: center;">
<span style="font-size: 12px;">ğŸ… ${task.pomodoroSessions}/${task.estimatedPomodoros}</span>
<button class="btn btn-primary btn-small" onclick="startTaskPomodoro('${task.id}')">
${currentTaskId === task.id && pomodoroActive ? 'ä½œæ¥­ä¸­' : 'ä½œæ¥­é–‹å§‹'}
</button>
</div>
`;

return card;
}

// æœŸé™ã‚¯ãƒ©ã‚¹åˆ¤å®š
function getDeadlineClass(endDate) {
const today = new Date();
const deadline = new Date(endDate);
const daysLeft = Math.ceil((deadline - today) / (1000 * 60 * 60 * 24));

if (daysLeft < 0) return 'deadline-overdue';
if (daysLeft <= 2) return 'deadline-urgent';
if (daysLeft <= 5) return 'deadline-soon';
return 'deadline-normal';
}

// æœŸé™åˆ‡ã‚Œã‚¿ã‚¹ã‚¯ãƒã‚§ãƒƒã‚¯
function checkOverdueTasks() {
const overdueTasks = [];
Object.values(tasks).forEach(genreTasks => {
genreTasks.forEach(task => {
if (new Date(task.endDate) < new Date() && !task.completed) {
overdueTasks.push(task);
}
});
});

if (overdueTasks.length > 0) {
document.getElementById('overdueAlert').style.display = 'block';
document.getElementById('overdueList').innerHTML = overdueTasks.map(task =>
`<div style="margin: 5px 0;">â€¢ ${task.title} (${new Date(task.endDate).toLocaleDateString('ja-JP')}æœŸé™)</div>`
).join('');
} else {
document.getElementById('overdueAlert').style.display = 'none';
}
}

// æœŸé™å†è¨­å®š
function rescheduleOverdue() {
const today = new Date();
Object.keys(tasks).forEach(genre => {
tasks[genre] = tasks[genre].map(task => {
if (new Date(task.endDate) < today && !task.completed) {
// ä»Šæ—¥ã‹ã‚‰åŒã˜æœŸé–“ã§å†è¨­å®š
const duration = Math.ceil((new Date(task.endDate) - new Date(task.startDate)) / (1000 * 60 * 60 * 24));
task.startDate = today.toISOString().split('T')[0];
task.endDate = new Date(today.getTime() + duration * 24 * 60 * 60 * 1000).toISOString().split('T')[0];
}
return task;
});
});
renderTasks();
checkOverdueTasks();
alert('æœŸé™ã‚’å†è¨­å®šã—ã¾ã—ãŸï¼æ–°ã—ã„æœŸé™ã§é ‘å¼µã‚Šã¾ã—ã‚‡ã†ï¼');
}

// é€²æ—çŠ¶æ³æ›´æ–°
function updateProgressSection() {
// ç¾åœ¨ã®æ³¨åŠ›ã‚¿ã‚¹ã‚¯
const activeTasks = [];
Object.values(tasks).forEach(genreTasks => {
genreTasks.forEach(task => {
if (!task.completed && task.pomodoroSessions > 0) {
activeTasks.push(task);
}
});
});

const focusElement = document.getElementById('currentFocus');
if (activeTasks.length > 0) {
const mostActive = activeTasks.sort((a, b) => b.pomodoroSessions - a.pomodoroSessions)[0];
focusElement.innerHTML = `ğŸ”¥ ç¾åœ¨æ³¨åŠ›ä¸­: <strong>${mostActive.title}</strong> (${mostActive.pomodoroSessions}ãƒãƒ¢ãƒ‰ãƒ¼ãƒ­å®Ÿæ–½)`;
} else {
focusElement.innerHTML = 'ğŸ“ ã¾ã ã‚¿ã‚¹ã‚¯ã‚’é–‹å§‹ã—ã¦ã„ã¾ã›ã‚“';
}

// ã‚¸ãƒ£ãƒ³ãƒ«åˆ¥é€²æ—
const progressBars = document.getElementById('genreProgressBars');
progressBars.innerHTML = '';

Object.entries(tasks).forEach(([genre, genreTasks]) => {
const total = genreTasks.length;
const completed = genreTasks.filter(t => t.completed).length;
const percentage = total > 0 ? (completed / total * 100) : 0;

progressBars.innerHTML += `
<div class="genre-progress">
<div style="display: flex; justify-content: space-between;">
<span>${genre}</span>
<span>${completed}/${total} å®Œäº†</span>
</div>
<div class="genre-progress-bar">
<div class="genre-progress-fill" style="width: ${percentage}%"></div>
</div>
</div>
`;
});
}

// ã‚¿ã‚¹ã‚¯è©³ç´°è¡¨ç¤º
function showTaskDetail(taskId) {
let task = null;
Object.values(tasks).forEach(genreTasks => {
const found = genreTasks.find(t => t.id === taskId);
if (found) task = found;
});

if (!task) return;

currentDetailTask = task;
document.getElementById('detailTitle').textContent = task.title;

const content = document.getElementById('detailContent');
content.innerHTML = `
<div style="margin-bottom: 15px;">
<strong>æœŸé–“:</strong> ${task.startDate} ã€œ ${task.endDate}<br>
<strong>é€²æ—:</strong> ${Math.round(task.progress)}%<br>
<strong>ãƒãƒ¢ãƒ‰ãƒ¼ãƒ­:</strong> ${task.pomodoroSessions}/${task.estimatedPomodoros}
</div>
<div style="background: #f5f5f5; padding: 10px; border-radius: 5px; margin-bottom: 15px;">
<strong>ä½œæ¥­è©³ç´°:</strong><br>
${task.details}
</div>
${task.subTasks ? `
<div>
<strong>ã‚µãƒ–ã‚¿ã‚¹ã‚¯:</strong>
${task.subTasks.map((sub, idx) => `
<div class="subtask-item">
<input type="checkbox" class="subtask-checkbox"
${sub.completed ? 'checked' : ''}
onchange="toggleSubtask('${task.id}', ${idx})">
<span>${sub.name}</span>
</div>
`).join('')}
</div>
` : ''}
`;

// ãƒ©ãƒ³ãƒ€ãƒ ãªåŠ±ã¾ã—ã®è¨€è‘‰
const randomQuote = quotes[Math.floor(Math.random() * quotes.length)];
document.getElementById('motivationalQuote').textContent = `"${randomQuote}"`;

document.getElementById('detailModal').style.display = 'flex';
}

// ã‚µãƒ–ã‚¿ã‚¹ã‚¯åˆ‡ã‚Šæ›¿ãˆ
function toggleSubtask(taskId, subIndex) {
Object.keys(tasks).forEach(genre => {
tasks[genre] = tasks[genre].map(task => {
if (task.id === taskId && task.subTasks) {
task.subTasks[subIndex].completed = !task.subTasks[subIndex].completed;
// ã‚µãƒ–ã‚¿ã‚¹ã‚¯ã®å®Œäº†çŠ¶æ³ã‹ã‚‰é€²æ—ã‚’è¨ˆç®—
const completedSubs = task.subTasks.filter(s => s.completed).length;
task.progress = Math.max(task.progress, (completedSubs / task.subTasks.length) * 50);
}
return task;
});
});
updateStats();
}

// è©³ç´°ã‹ã‚‰ãƒãƒ¢ãƒ‰ãƒ¼ãƒ­é–‹å§‹
function startDetailPomodoro() {
if (currentDetailTask) {
startTaskPomodoro(currentDetailTask.id);
hideModal('detailModal');
}
}

// ã‚¿ã‚¹ã‚¯è¿½åŠ ãƒ¢ãƒ¼ãƒ€ãƒ«è¡¨ç¤º
function showAddTaskModal(genre) {
currentEditGenre = genre;
document.getElementById('taskModalTitle').textContent = `${genre} - ã‚¿ã‚¹ã‚¯è¿½åŠ `;
document.getElementById('taskModal').style.display = 'flex';

// æ—¥ä»˜ã®åˆæœŸå€¤è¨­å®š
const today = new Date().toISOString().split('T')[0];
document.getElementById('taskStartDate').value = today;
document.getElementById('taskEndDate').value = today;
}

// ã‚¿ã‚¹ã‚¯ä¿å­˜
function saveTask() {
const task = {
id: `${currentEditGenre}-${Date.now()}`,
genre: currentEditGenre,
title: document.getElementById('taskTitle').value,
type: document.getElementById('taskType').value,
startDate: document.getElementById('taskStartDate').value,
endDate: document.getElementById('taskEndDate').value,
estimatedPomodoros: parseInt(document.getElementById('taskPomodoros').value),
priority: document.getElementById('taskPriority').value,
details: document.getElementById('taskDetails').value,
progress: 0,
pomodoroSessions: 0,
completed: false
};

tasks[currentEditGenre].push(task);
renderTasks();
updateStats();
hideModal('taskModal');

// ãƒ•ã‚©ãƒ¼ãƒ ãƒªã‚»ãƒƒãƒˆ
document.getElementById('taskTitle').value = '';
document.getElementById('taskDetails').value = '';
}

// ã‚¿ã‚¹ã‚¯å‰Šé™¤
function deleteTask(taskId) {
if (confirm('ã“ã®ã‚¿ã‚¹ã‚¯ã‚’å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿ')) {
Object.keys(tasks).forEach(genre => {
tasks[genre] = tasks[genre].filter(task => task.id !== taskId);
});
renderTasks();
updateStats();
}
}

// ã‚¿ã‚¹ã‚¯å®Œäº†åˆ‡ã‚Šæ›¿ãˆ
function toggleTask(taskId) {
Object.keys(tasks).forEach(genre => {
tasks[genre] = tasks[genre].map(task => {
if (task.id === taskId) {
task.completed = !task.completed;
if (task.completed) {
task.progress = 100;
motivationLevel = Math.min(100, motivationLevel + 10);
updateMotivation();
}
}
return task;
});
});
renderTasks();
updateStats();
updateProgressSection();
}

// ãƒãƒ¢ãƒ‰ãƒ¼ãƒ­ã‚¿ã‚¤ãƒãƒ¼
function togglePomodoro() {
pomodoroActive = !pomodoroActive;
if (pomodoroActive) {
pomodoroInterval = setInterval(updatePomodoro, 1000);
} else {
clearInterval(pomodoroInterval);
}
}

function updatePomodoro() {
if (pomodoroTime > 0) {
pomodoroTime--;
const minutes = Math.floor(pomodoroTime / 60);
const seconds = pomodoroTime % 60;
document.getElementById('pomodoroTime').textContent =
`${minutes}:${seconds.toString().padStart(2, '0')}`;
} else {
completePomodoro();
}
}

function completePomodoro() {
pomodoroActive = false;
clearInterval(pomodoroInterval);
pomodoroTime = 25 * 60;

// ä»Šæ—¥ã®é€²æ—æ›´æ–°
const today = new Date().toISOString().split('T')[0];
dailyProgress[today] = (dailyProgress[today] || 0) + 1;

// ç¾åœ¨ã®ã‚¿ã‚¹ã‚¯ã®é€²æ—æ›´æ–°
if (currentTaskId) {
Object.keys(tasks).forEach(genre => {
tasks[genre] = tasks[genre].map(task => {
if (task.id === currentTaskId) {
task.pomodoroSessions++;
task.progress = Math.min(100, (task.pomodoroSessions / task.estimatedPomodoros) * 100);
}
return task;
});
});
}

motivationLevel = Math.min(100, motivationLevel + 5);
updateMotivation();
updateTodayProgress();
renderTasks();
updateStats();
updateProgressSection();

alert('ğŸ‰ ãƒãƒ¢ãƒ‰ãƒ¼ãƒ­å®Œäº†ï¼5åˆ†ä¼‘æ†©ã—ã¦ãã ã•ã„');
}

function startTaskPomodoro(taskId) {
currentTaskId = taskId;
if (!pomodoroActive) {
togglePomodoro();
}
}

// ä»Šæ—¥ã®é€²æ—æ›´æ–°
function updateTodayProgress() {
const today = new Date().toISOString().split('T')[0];
const todayCount = dailyProgress[today] || 0;

document.getElementById('todayCount').textContent = todayCount;

const dots = document.querySelectorAll('.pomodoro-dot');
dots.forEach((dot, index) => {
if (index < todayCount) {
dot.classList.add('filled');
} else {
dot.classList.remove('filled');
}
});
}

// ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼è¡¨ç¤º
function showCalendarModal() {
const calendar = document.getElementById('calendarContent');
const today = new Date();
const year = today.getFullYear();
const month = today.getMonth();
const firstDay = new Date(year, month, 1);
const lastDay = new Date(year, month + 1, 0);
const daysInMonth = lastDay.getDate();

let html = '<div class="calendar">';

// æ›œæ—¥ãƒ˜ãƒƒãƒ€ãƒ¼
const weekDays = ['æ—¥', 'æœˆ', 'ç«', 'æ°´', 'æœ¨', 'é‡‘', 'åœŸ'];
weekDays.forEach(day => {
html += `<div style="font-weight: bold; text-align: center; padding: 5px;">${day}</div>`;
});

// æœˆåˆã®ç©ºç™½
for (let i = 0; i < firstDay.getDay(); i++) {
html += '<div></div>';
}

// æ—¥ä»˜
for (let day = 1; day <= daysInMonth; day++) {
const date = new Date(year, month, day);
const dateStr = date.toISOString().split('T')[0];
const pomodoros = dailyProgress[dateStr] || 0;
const isToday = day === today.getDate();

let emoji = '';
if (pomodoros >= 8) emoji = 'ğŸ†';
else if (pomodoros >= 4) emoji = 'â­';
else if (pomodoros > 0) emoji = 'âœ“';

html += `
<div class="calendar-day ${isToday ? 'today' : ''}">
<div class="calendar-day-number">${day}</div>
${emoji ? `<div>${emoji}</div>` : ''}
${pomodoros > 0 ? `<div class="calendar-day-pomodoros">${pomodoros}ğŸ…</div>` : ''}
</div>
`;
}

html += '</div>';
calendar.innerHTML = html;
document.getElementById('calendarModal').style.display = 'flex';
}

// ãƒ¢ãƒãƒ™ãƒ¼ã‚·ãƒ§ãƒ³æ›´æ–°
function updateMotivation() {
document.getElementById('motivationBar').style.width = `${motivationLevel}%`;
let text = '';
if (motivationLevel >= 90) text = 'ğŸ”¥ çµ¶å¥½èª¿ï¼';
else if (motivationLevel >= 70) text = 'â­ ã„ã„æ„Ÿã˜ï¼';
else if (motivationLevel >= 50) text = 'ğŸ’– ãã®èª¿å­ï¼';
else text = 'â˜• ä¼‘æ†©ã‚‚å¤§åˆ‡';
document.getElementById('motivationText').textContent = `${text} ${motivationLevel}%`;
}

// çµ±è¨ˆæ›´æ–°
function updateStats() {
let completed = 0;
let pomodoros = 0;
let words = 0;

Object.values(tasks).forEach(genreTasks => {
genreTasks.forEach(task => {
if (task.completed) completed++;
pomodoros += task.pomodoroSessions;
if (task.type === 'writing') {
words += Math.floor(task.progress * 720);
}
});
});

document.getElementById('completedCount').textContent = completed;
document.getElementById('pomodoroCount').textContent = pomodoros;
document.getElementById('wordCount').textContent = words.toLocaleString();
}

// AIã‚¢ãƒ‰ãƒã‚¤ã‚¹æ›´æ–°
function updateAIAdvice() {
const allTasks = Object.values(tasks).flat().filter(t => !t.completed);
const sortedTasks = allTasks.sort((a, b) => {
const scoreA = calculatePriority(a);
const scoreB = calculatePriority(b);
return scoreB - scoreA;
});

const advice = document.getElementById('aiAdvice');
if (sortedTasks.length > 0) {
advice.innerHTML = sortedTasks.slice(0, 3).map((task, index) =>
`<div style="padding: 5px 0;">
<strong>#${index + 1}</strong> ${task.title}
<span style="font-size: 12px; color: #666;">
(æœŸé™: ${new Date(task.endDate).toLocaleDateString('ja-JP')})
</span>
</div>`
).join('');
} else {
advice.innerHTML = 'ã™ã¹ã¦ã®ã‚¿ã‚¹ã‚¯ãŒå®Œäº†ã—ã¦ã„ã¾ã™ï¼ğŸ‰';
}
}

function calculatePriority(task) {
const today = new Date();
const deadline = new Date(task.endDate);
const daysLeft = Math.ceil((deadline - today) / (1000 * 60 * 60 * 24));

let score = 0;
if (daysLeft < 0) score += 100;
else if (daysLeft <= 2) score += 80;
else if (daysLeft <= 5) score += 50;

if (task.priority === 'high') score += 40;
else if (task.priority === 'medium') score += 20;

return score;
}

// ã‚¸ãƒ£ãƒ³ãƒ«é¸æŠ
function selectGenre(genre) {
selectedGenre = genre;
document.querySelectorAll('.genre-tab').forEach(tab => {
tab.classList.remove('active');
if (tab.textContent === genre) {
tab.classList.add('active');
}
});
renderTasks();
}

// ã‚¸ãƒ£ãƒ³ãƒ«è¿½åŠ ãƒ¢ãƒ¼ãƒ€ãƒ«
function showAddGenreModal() {
document.getElementById('genreModal').style.display = 'flex';
}

function hideModal(modalId) {
document.getElementById(modalId).style.display = 'none';
}

function addGenre() {
const input = document.getElementById('genreInput');
const genreName = input.value.trim();

if (genreName && !genres.includes(genreName)) {
genres.push(genreName);
tasks[genreName] = generateTasksForGenre(genreName);

// ã‚¿ãƒ–è¿½åŠ 
const tabsContainer = document.querySelector('.genre-tabs');
const newTab = document.createElement('div');
newTab.className = 'genre-tab';
newTab.textContent = genreName;
newTab.onclick = () => selectGenre(genreName);
tabsContainer.insertBefore(newTab, tabsContainer.lastElementChild);

renderTasks();
updateStats();
updateProgressSection();
motivationLevel = Math.min(100, motivationLevel + 10);
updateMotivation();
}

input.value = '';
hideModal('genreModal');
}

// åˆæœŸåŒ–å®Ÿè¡Œ
init();
</script>
```// ===== IndexedDBè¨­å®š =====
let db;
const DB_NAME = 'DreamNovelDB';
const DB_VERSION = 1;
const STORE_NAME = 'userData';

// IndexedDBåˆæœŸåŒ–
function initDB() {
    return new Promise((resolve, reject) => {
        const request = indexedDB.open(DB_NAME, DB_VERSION);
        
        request.onerror = () => {
            console.error('IndexedDBé–‹ã‘ã¾ã›ã‚“ã§ã—ãŸ');
            reject(request.error);
        };
        
        request.onsuccess = () => {
            db = request.result;
            console.log('IndexedDBæ¥ç¶šæˆåŠŸ');
            resolve(db);
        };
        
        request.onupgradeneeded = (event) => {
            db = event.target.result;
            
            // ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚¹ãƒˆã‚¢ãŒå­˜åœ¨ã—ãªã„å ´åˆã¯ä½œæˆ
            if (!db.objectStoreNames.contains(STORE_NAME)) {
                const objectStore = db.createObjectStore(STORE_NAME, { keyPath: 'id' });
                objectStore.createIndex('timestamp', 'timestamp', { unique: false });
                console.log('ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚¹ãƒˆã‚¢ä½œæˆå®Œäº†');
            }
        };
    });
}

// ãƒ‡ãƒ¼ã‚¿ä¿å­˜ï¼ˆè‡ªå‹•ä¿å­˜ï¼‰
async function saveToIndexedDB() {
    if (!db) {
        await initDB();
    }
    
    return new Promise((resolve, reject) => {
        const transaction = db.transaction([STORE_NAME], 'readwrite');
        const store = transaction.objectStore(STORE_NAME);
        
        const data = {
            id: 'mainData',
            tasks: tasks,
            genres: genres,
            dailyProgress: dailyProgress,
            selectedGenre: selectedGenre,
            motivationLevel: motivationLevel,
            timestamp: new Date().toISOString(),
            lastModified: Date.now()
        };
        
        const request = store.put(data);
        
        request.onsuccess = () => {
            console.log('ãƒ‡ãƒ¼ã‚¿ä¿å­˜æˆåŠŸ:', new Date().toLocaleTimeString());
            resolve();
        };
        
        request.onerror = () => {
            console.error('ãƒ‡ãƒ¼ã‚¿ä¿å­˜å¤±æ•—');
            reject(request.error);
        };
    });
}

// ãƒ‡ãƒ¼ã‚¿èª­ã¿è¾¼ã¿
async function loadFromIndexedDB() {
    if (!db) {
        await initDB();
    }
    
    return new Promise((resolve, reject) => {
        const transaction = db.transaction([STORE_NAME], 'readonly');
        const store = transaction.objectStore(STORE_NAME);
        const request = store.get('mainData');
        
        request.onsuccess = () => {
            if (request.result) {
                const data = request.result;
                tasks = data.tasks || {};
                genres = data.genres || ['TRICK', 'KILLERS'];
                dailyProgress = data.dailyProgress || {};
                selectedGenre = data.selectedGenre || 'å…¨ä½“';
                motivationLevel = data.motivationLevel || 75;
                
                console.log('ãƒ‡ãƒ¼ã‚¿èª­ã¿è¾¼ã¿æˆåŠŸ:', data.timestamp);
                resolve(data);
            } else {
                console.log('ä¿å­˜ãƒ‡ãƒ¼ã‚¿ãªã— - åˆæœŸãƒ‡ãƒ¼ã‚¿ã‚’ä½¿ç”¨');
                resolve(null);
            }
        };
        
        request.onerror = () => {
            console.error('ãƒ‡ãƒ¼ã‚¿èª­ã¿è¾¼ã¿å¤±æ•—');
            reject(request.error);
        };
    });
}

// ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ãƒ‡ãƒ¼ã‚¿ã®ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ
function exportBackup() {
    const data = {
        tasks: tasks,
        genres: genres,
        dailyProgress: dailyProgress,
        selectedGenre: selectedGenre,
        motivationLevel: motivationLevel,
        exportDate: new Date().toISOString(),
        version: '1.0'
    };
    
    const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `dream-novel-backup-${new Date().toISOString().split('T')[0]}.json`;
    a.click();
    URL.revokeObjectURL(url);
    
    alert('ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã—ã¾ã—ãŸ');
}

// ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ãƒ‡ãƒ¼ã‚¿ã®ã‚¤ãƒ³ãƒãƒ¼ãƒˆ
function importBackup() {
    const input = document.createElement('input');
    input.type = 'file';
    input.accept = '.json';
    
    input.onchange = async (e) => {
        const file = e.target.files[0];
        if (!file) return;
        
        const reader = new FileReader();
        reader.onload = async (event) => {
            try {
                const data = JSON.parse(event.target.result);
                
                // ãƒ‡ãƒ¼ã‚¿ã‚’å¾©å…ƒ
                tasks = data.tasks || {};
                genres = data.genres || ['TRICK', 'KILLERS'];
                dailyProgress = data.dailyProgress || {};
                selectedGenre = data.selectedGenre || 'å…¨ä½“';
                motivationLevel = data.motivationLevel || 75;
                
                // IndexedDBã«ä¿å­˜
                await saveToIndexedDB();
                
                // UIã‚’æ›´æ–°
                renderTasks();
                updateStats();
                updateMotivation();
                updateProgressSection();
                
                alert('ãƒ‡ãƒ¼ã‚¿ã®ã‚¤ãƒ³ãƒãƒ¼ãƒˆãŒå®Œäº†ã—ã¾ã—ãŸï¼');
            } catch (error) {
                console.error('ã‚¤ãƒ³ãƒãƒ¼ãƒˆå¤±æ•—:', error);
                alert('ãƒ•ã‚¡ã‚¤ãƒ«ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸ');
            }
        };
        
        reader.readAsText(file);
    };
    
    input.click();
}

// è‡ªå‹•ä¿å­˜ï¼ˆå¤‰æ›´ãŒã‚ã£ãŸå ´åˆï¼‰
let saveTimeout;
function autoSave() {
    clearTimeout(saveTimeout);
    saveTimeout = setTimeout(() => {
        saveToIndexedDB().catch(console.error);
    }, 1000); // 1ç§’å¾Œã«ä¿å­˜
}

// æ—¢å­˜ã®é–¢æ•°ã‚’ä¿®æ­£ - ãƒ‡ãƒ¼ã‚¿å¤‰æ›´æ™‚ã«è‡ªå‹•ä¿å­˜ã‚’å‘¼ã³å‡ºã™
const originalToggleTask = toggleTask;
toggleTask = function(taskId) {
    originalToggleTask(taskId);
    autoSave();
};

const originalSaveTask = saveTask;
saveTask = function() {
    originalSaveTask();
    autoSave();
};

const originalDeleteTask = deleteTask;
deleteTask = function(taskId) {
    originalDeleteTask(taskId);
    autoSave();
};

const originalCompletePomodoro = completePomodoro;
completePomodoro = function() {
    originalCompletePomodoro();
    autoSave();
};

// åˆæœŸåŒ–é–¢æ•°ã‚’ä¿®æ­£
async function init() {
    try {
        // IndexedDBã‹ã‚‰èª­ã¿è¾¼ã¿
        await loadFromIndexedDB();
        
        // ãƒ‡ãƒ¼ã‚¿ãŒãªã„å ´åˆã¯åˆæœŸãƒ‡ãƒ¼ã‚¿ã‚’ç”Ÿæˆ
        if (Object.keys(tasks).length === 0) {
            generateInitialTasks();
        }
        
        // UIæ›´æ–°
        renderTasks();
        updateStats();
        updateAIAdvice();
        checkOverdueTasks();
        updateProgressSection();
        updateMotivation();
        updateTodayProgress();
        
    } catch (error) {
        console.error('åˆæœŸåŒ–ã‚¨ãƒ©ãƒ¼:', error);
        // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: localStorageä½¿ç”¨
        const saved = localStorage.getItem('dreamNovelData');
        if (saved) {
            const data = JSON.parse(saved);
            tasks = data.tasks || {};
            genres = data.genres || ['TRICK', 'KILLERS'];
            dailyProgress = data.dailyProgress || {};
        } else {
            generateInitialTasks();
        }
        renderTasks();
        updateStats();
    }
}

// ãƒšãƒ¼ã‚¸é›¢è„±æ™‚ã®ä¿å­˜
window.addEventListener('beforeunload', () => {
    // åŒæœŸçš„ã«ä¿å­˜ï¼ˆéæ¨å¥¨ã ãŒç¢ºå®Ÿï¼‰
    const data = {
        tasks: tasks,
        genres: genres,
        dailyProgress: dailyProgress,
        selectedGenre: selectedGenre,
        motivationLevel: motivationLevel
    };
    localStorage.setItem('dreamNovelData', JSON.stringify(data));
});

// å®šæœŸçš„ãªè‡ªå‹•ä¿å­˜ï¼ˆ5åˆ†ã”ã¨ï¼‰
setInterval(() => {
    saveToIndexedDB().catch(console.error);
}, 5 * 60 * 1000);

</body>
</html>

