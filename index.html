<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>夢小説創作ダッシュボード</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        /* ダークモードベースのデザイン */
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            min-height: 100vh;
            padding: 10px;
            color: #e0e0e0;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
        }
        
        .header {
            background: rgba(30, 30, 45, 0.95);
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            border: 1px solid rgba(255,255,255,0.1);
        }
        
        .title {
            font-size: 24px;
            color: #fff;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .sync-indicator {
            margin-left: auto;
            padding: 5px 10px;
            background: rgba(76, 175, 80, 0.2);
            border: 1px solid #4caf50;
            border-radius: 20px;
            font-size: 12px;
            color: #4caf50;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .sync-indicator.syncing {
            background: rgba(255, 152, 0, 0.2);
            border-color: #ff9800;
            color: #ff9800;
        }
        
        .motivation-bar {
            width: 200px;
            height: 20px;
            background: rgba(255,255,255,0.1);
            border-radius: 10px;
            overflow: hidden;
            margin: 10px 0;
            border: 1px solid rgba(255,255,255,0.2);
        }
        
        .motivation-fill {
            height: 100%;
            background: linear-gradient(90deg, #f093fb 0%, #f5576c 100%);
            transition: width 0.3s ease;
        }
        
        .pomodoro-timer {
            display: inline-flex;
            align-items: center;
            gap: 10px;
            background: rgba(255, 107, 107, 0.2);
            padding: 10px 20px;
            border-radius: 25px;
            font-size: 20px;
            font-weight: bold;
            border: 1px solid rgba(255, 107, 107, 0.5);
            color: #fff;
        }

        .pomodoro-controls {
            display: flex;
            gap: 5px;
        }
        
        .btn {
            padding: 8px 16px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s ease;
            font-weight: 500;
        }

        .btn:active {
            transform: scale(0.95);
        }
        
        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }
        
        .btn-primary:hover {
            background: linear-gradient(135deg, #5a67d8 0%, #6b4299 100%);
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }
        
        .btn-success {
            background: linear-gradient(135deg, #48bb78 0%, #38a169 100%);
            color: white;
        }

        .btn-success:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(72, 187, 120, 0.4);
        }
        
        .btn-danger {
            background: linear-gradient(135deg, #f56565 0%, #e53e3e 100%);
            color: white;
        }

        .btn-warning {
            background: linear-gradient(135deg, #ed8936 0%, #dd6b20 100%);
            color: white;
        }

        .btn-secondary {
            background: rgba(255,255,255,0.1);
            color: white;
            border: 1px solid rgba(255,255,255,0.2);
        }

        .btn-secondary:hover {
            background: rgba(255,255,255,0.2);
        }
        
        .genre-tabs {
            display: flex;
            gap: 10px;
            margin: 20px 0;
            flex-wrap: wrap;
            align-items: center;
        }
        
        .genre-tab {
            padding: 8px 16px;
            background: rgba(255,255,255,0.1);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            color: #e0e0e0;
            border: 1px solid rgba(255,255,255,0.2);
            position: relative;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .genre-tab:hover {
            background: rgba(255,255,255,0.2);
            transform: translateY(-2px);
        }
        
        .genre-tab.active {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
        }

        .genre-tab .sparkle {
            animation: sparkle 1.5s ease-in-out infinite;
        }

        @keyframes sparkle {
            0%, 100% { opacity: 0.5; transform: scale(1); }
            50% { opacity: 1; transform: scale(1.2); }
        }

        .genre-actions {
            display: none;
            position: absolute;
            top: -5px;
            right: -5px;
            gap: 2px;
        }

        .genre-tab:hover .genre-actions {
            display: flex;
        }

        .genre-action-btn {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            border: none;
            cursor: pointer;
            font-size: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .task-card {
            background: rgba(30, 30, 45, 0.95);
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 15px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            transition: all 0.3s ease;
            position: relative;
            border: 1px solid rgba(255,255,255,0.1);
            cursor: pointer;
        }

        .task-card.priority {
            border-left: 3px solid #ffd700;
            background: rgba(255, 215, 0, 0.05);
        }

        .task-card.r18 {
            background: rgba(220, 20, 60, 0.1);
            border: 1px solid rgba(220, 20, 60, 0.3);
        }
        
        .task-card.overdue {
            border-left: 5px solid #ff4444;
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0% { box-shadow: 0 4px 15px rgba(255,0,0,0.2); }
            50% { box-shadow: 0 4px 25px rgba(255,0,0,0.4); }
            100% { box-shadow: 0 4px 15px rgba(255,0,0,0.2); }
        }
        
        .task-card:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.3);
            border-color: rgba(102, 126, 234, 0.5);
        }
        
        .task-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        
        .task-title {
            font-weight: bold;
            font-size: 16px;
            color: #fff;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .task-title:hover {
            color: #667eea;
        }

        .crown-icon {
            color: #ffd700;
            font-size: 18px;
        }
        
        .task-deadline {
            padding: 4px 8px;
            border-radius: 5px;
            color: white;
            font-size: 12px;
        }
        
        .deadline-overdue {
            background: #ff4444;
            animation: blink 1s infinite;
        }
        
        @keyframes blink {
            0%, 50%, 100% { opacity: 1; }
            25%, 75% { opacity: 0.7; }
        }
        
        .deadline-urgent {
            background: #f56565;
        }
        
        .deadline-soon {
            background: #ed8936;
        }
        
        .deadline-normal {
            background: #48bb78;
        }
        
        .progress-bar {
            width: 100%;
            height: 10px;
            background: rgba(255,255,255,0.1);
            border-radius: 5px;
            overflow: hidden;
            margin: 10px 0;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
            transition: width 0.3s ease;
        }

        .subtasks-container {
            margin-top: 10px;
            padding: 10px;
            background: rgba(0,0,0,0.2);
            border-radius: 8px;
        }

        .subtask-item {
            padding: 8px;
            margin: 5px 0;
            background: rgba(255,255,255,0.05);
            border-radius: 5px;
            display: flex;
            align-items: center;
            gap: 10px;
            transition: all 0.2s ease;
        }

        .subtask-item:hover {
            background: rgba(255,255,255,0.1);
        }

        .subtask-item.completed {
            opacity: 0.6;
            text-decoration: line-through;
        }

        .subtask-checkbox {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }
        
        .ai-advice {
            background: rgba(255, 193, 7, 0.1);
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 20px;
            border: 1px solid rgba(255, 193, 7, 0.3);
            color: #fff;
        }

        .ai-advice-item {
            padding: 8px;
            margin: 5px 0;
            background: rgba(0,0,0,0.2);
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .ai-advice-item:hover {
            background: rgba(102, 126, 234, 0.2);
            transform: translateX(5px);
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }
        
        .stat-card {
            background: rgba(30, 30, 45, 0.95);
            border-radius: 10px;
            padding: 15px;
            text-align: center;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            border: 1px solid rgba(255,255,255,0.1);
        }
        
        .stat-number {
            font-size: 24px;
            font-weight: bold;
            color: #667eea;
        }
        
        .stat-label {
            font-size: 12px;
            color: #999;
            margin-top: 5px;
        }
        
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            justify-content: center;
            align-items: center;
            z-index: 1000;
            animation: fadeIn 0.3s ease;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        
        .modal-content {
            background: #1a1a2e;
            border-radius: 15px;
            padding: 25px;
            max-width: 600px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            border: 1px solid rgba(255,255,255,0.1);
            animation: slideUp 0.3s ease;
        }

        @keyframes slideUp {
            from { transform: translateY(50px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }

        .modal-content h3 {
            color: #fff;
            margin-bottom: 20px;
        }
        
        .checkbox {
            width: 20px;
            height: 20px;
            margin-right: 10px;
            cursor: pointer;
            accent-color: #667eea;
        }
        
        .completed {
            text-decoration: line-through;
            opacity: 0.6;
        }
        
        .today-progress {
            background: rgba(168, 237, 234, 0.1);
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 20px;
            border: 1px solid rgba(168, 237, 234, 0.3);
        }
        
        .pomodoro-dots {
            display: flex;
            gap: 5px;
            margin: 10px 0;
        }
        
        .pomodoro-dot {
            width: 25px;
            height: 25px;
            border-radius: 50%;
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.2);
            transition: all 0.3s ease;
        }
        
        .pomodoro-dot.filled {
            background: linear-gradient(135deg, #ff6b6b 0%, #ff4444 100%);
            box-shadow: 0 0 10px rgba(255, 107, 107, 0.5);
        }

        .progress-section {
            background: rgba(137, 247, 254, 0.1);
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 20px;
            color: white;
            border: 1px solid rgba(137, 247, 254, 0.3);
        }

        .memo-section {
            background: rgba(30, 30, 45, 0.95);
            border-radius: 15px;
            padding: 20px;
            margin-top: 20px;
            border: 1px solid rgba(255,255,255,0.1);
        }

        .memo-item {
            background: rgba(255,255,255,0.05);
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 1px solid rgba(255,255,255,0.1);
        }

        .memo-item:hover {
            background: rgba(255,255,255,0.1);
            transform: translateY(-2px);
        }

        .memo-item.expanded {
            background: rgba(102, 126, 234, 0.1);
        }

        .memo-title {
            font-weight: bold;
            color: #fff;
            margin-bottom: 5px;
        }

        .memo-preview {
            color: #999;
            font-size: 14px;
            overflow: hidden;
            text-overflow: ellipsis;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
        }

        .memo-content {
            color: #e0e0e0;
            font-size: 14px;
            margin-top: 10px;
            display: none;
        }

        .memo-item.expanded .memo-content {
            display: block;
        }

        .memo-item.expanded .memo-preview {
            display: none;
        }

        .habit-tracker {
            background: rgba(30, 30, 45, 0.95);
            border-radius: 15px;
            padding: 20px;
            margin-top: 20px;
            border: 1px solid rgba(255,255,255,0.1);
        }

        .habit-grid {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            gap: 5px;
            margin-top: 15px;
        }

        .habit-cell {
            aspect-ratio: 1;
            background: rgba(255,255,255,0.05);
            border-radius: 5px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s ease;
            border: 1px solid rgba(255,255,255,0.1);
        }

        .habit-cell:hover {
            background: rgba(102, 126, 234, 0.2);
        }

        .habit-cell.completed {
            background: linear-gradient(135deg, #48bb78 0%, #38a169 100%);
        }

        .weekly-goals {
            background: rgba(30, 30, 45, 0.95);
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 20px;
            border: 1px solid rgba(255,255,255,0.1);
        }

        .goal-input {
            width: 100%;
            padding: 10px;
            background: rgba(255,255,255,0.05);
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 5px;
            color: #fff;
            margin-top: 10px;
        }

        .goal-input:focus {
            outline: none;
            border-color: #667eea;
            background: rgba(255,255,255,0.1);
        }
        
        input[type="text"], input[type="date"], input[type="number"], select, textarea {
            width: 100%;
            padding: 10px;
            margin: 5px 0;
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 5px;
            background: rgba(255,255,255,0.05);
            color: #fff;
        }

        input:focus, select:focus, textarea:focus {
            outline: none;
            border-color: #667eea;
            background: rgba(255,255,255,0.1);
        }

        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 15px 20px;
            border-radius: 10px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            z-index: 10000;
            animation: slideInRight 0.5s ease;
        }

        @keyframes slideInRight {
            from { transform: translateX(100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }

        .calendar-view {
            background: rgba(30, 30, 45, 0.95);
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 20px;
            border: 1px solid rgba(255,255,255,0.1);
        }

        .calendar-grid {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            gap: 5px;
            margin-top: 15px;
        }

        .calendar-day {
            aspect-ratio: 1;
            background: rgba(255,255,255,0.05);
            border-radius: 5px;
            padding: 5px;
            font-size: 11px;
            border: 1px solid rgba(255,255,255,0.1);
            position: relative;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .calendar-day:hover {
            background: rgba(255,255,255,0.1);
        }

        .calendar-day.today {
            background: rgba(102, 126, 234, 0.2);
            border-color: #667eea;
        }

        .calendar-day.has-tasks {
            background: rgba(72, 187, 120, 0.1);
        }

        .calendar-day-number {
            font-weight: bold;
            color: #fff;
        }

        .calendar-day-tasks {
            font-size: 9px;
            color: #999;
            margin-top: 2px;
        }

        .tag-container {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            margin: 10px 0;
        }

        .tag {
            padding: 4px 10px;
            background: rgba(102, 126, 234, 0.2);
            border-radius: 15px;
            font-size: 12px;
            color: #667eea;
            border: 1px solid rgba(102, 126, 234, 0.3);
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .tag:hover {
            background: rgba(102, 126, 234, 0.3);
        }

        .tag.r18 {
            background: rgba(220, 20, 60, 0.2);
            color: #dc143c;
            border-color: rgba(220, 20, 60, 0.3);
        }

        .backup-controls {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }
        
        @media (max-width: 768px) {
            .title {
                font-size: 18px;
            }
            
            .pomodoro-timer {
                font-size: 16px;
                padding: 8px 15px;
            }
            
            .stats-grid {
                grid-template-columns: repeat(2, 1fr);
            }
            
            .modal-content {
                padding: 15px;
            }

            .calendar-grid, .habit-grid {
                grid-template-columns: repeat(7, 1fr);
                gap: 2px;
            }

            .calendar-day {
                font-size: 9px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- ヘッダー -->
        <div class="header">
            <div class="title">
                <span>✨</span>
                <span>夢小説創作ダッシュボード</span>
                <div class="sync-indicator" id="syncIndicator">
                    <span id="syncIcon">✓</span>
                    <span id="syncText">保存済み</span>
                </div>
            </div>

            <div class="backup-controls">
                <button class="btn btn-secondary btn-small" onclick="saveToLocal()">
                    💾 ローカル保存
                </button>
                <button class="btn btn-secondary btn-small" onclick="exportData()">
                    📥 エクスポート
                </button>
                <button class="btn btn-secondary btn-small" onclick="importData()">
                    📤 インポート
                </button>
                <input type="file" id="importFile" style="display: none;" accept=".json" onchange="handleImport(event)">
            </div>

            <div style="display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 15px; margin-top: 15px;">
                <div>
                    <div style="font-size: 14px; color: #999;">モチベーション</div>
                    <div class="motivation-bar">
                        <div class="motivation-fill" id="motivationBar" style="width: 75%;"></div>
                    </div>
                    <div id="motivationText" style="font-size: 12px; color: #999;">いい感じ！ 75%</div>
                </div>
                
                <div class="pomodoro-timer">
                    <span>🍅</span>
                    <span id="pomodoroTime">25:00</span>
                    <div class="pomodoro-controls">
                        <button class="btn btn-primary btn-small" id="pomodoroToggle" onclick="togglePomodoro()">開始</button>
                        <button class="btn btn-secondary btn-small" onclick="pausePomodoro()">⏸</button>
                        <button class="btn btn-secondary btn-small" onclick="resetPomodoro()">↻</button>
                    </div>
                </div>
            </div>
            
            <div class="genre-tabs" id="genreTabs">
                <div class="genre-tab active" onclick="selectGenre('全体')">全体</div>
                <button class="btn btn-success" onclick="showAddGenreModal()">+ ジャンル追加</button>
            </div>
        </div>

        <!-- 週間目標 -->
        <div class="weekly-goals">
            <h3 style="color: #fff;">🎯 今週の目標</h3>
            <input type="text" class="goal-input" id="weeklyGoal" placeholder="例: 夢小説を2作品完成させる" onchange="saveGoal()">
            <div id="goalProgress" style="margin-top: 10px; color: #999; font-size: 14px;"></div>
        </div>
        
        <!-- 進捗状況 -->
        <div class="progress-section">
            <h3>📊 現在の進捗状況</h3>
            <div id="currentFocus" style="margin: 10px 0; font-size: 14px;"></div>
            <div id="genreProgressBars"></div>
        </div>
        
        <!-- 今日の進捗 -->
        <div class="today-progress">
            <div style="display: flex; justify-content: space-between; align-items: center;">
                <div>
                    <h3 style="color: #fff;">📊 今日の達成度</h3>
                    <div class="pomodoro-dots" id="todayProgress">
                        <div class="pomodoro-dot"></div>
                        <div class="pomodoro-dot"></div>
                        <div class="pomodoro-dot"></div>
                        <div class="pomodoro-dot"></div>
                        <div class="pomodoro-dot"></div>
                        <div class="pomodoro-dot"></div>
                        <div class="pomodoro-dot"></div>
                        <div class="pomodoro-dot"></div>
                    </div>
                    <div style="font-size: 14px; color: #999;">
                        <span id="todayCount">0</span>/8 ポモドーロ完了
                    </div>
                </div>
                <button class="btn btn-primary" onclick="toggleCalendarView()">
                    📅 カレンダー表示
                </button>
            </div>
        </div>

        <!-- カレンダービュー -->
        <div class="calendar-view" id="calendarView" style="display: none;">
            <h3 style="color: #fff;">📅 月間スケジュール</h3>
            <div class="calendar-grid" id="calendarGrid"></div>
        </div>
        
        <!-- AIアドバイス -->
        <div class="ai-advice">
            <h3 style="margin-bottom: 10px;">🤖 AI推奨: 優先タスク</h3>
            <div id="aiAdvice">
                分析中...
            </div>
        </div>
        
        <!-- タスクリスト -->
        <div id="taskList"></div>

        <!-- メモセクション -->
        <div class="memo-section">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                <h3 style="color: #fff;">📝 メモ</h3>
                <button class="btn btn-primary btn-small" onclick="showMemoModal()">+ メモ追加</button>
            </div>
            <div id="memoList"></div>
        </div>

        <!-- ハビットトラッカー -->
        <div class="habit-tracker">
            <h3 style="color: #fff; margin-bottom: 10px;">📈 習慣トラッカー</h3>
            <div style="display: flex; gap: 20px; margin-bottom: 15px;">
                <div>
                    <span style="color: #999;">分析作業</span>
                    <div class="habit-grid" id="analysisHabit"></div>
                </div>
                <div>
                    <span style="color: #999;">創作作業</span>
                    <div class="habit-grid" id="creationHabit"></div>
                </div>
            </div>
        </div>
        
        <!-- 統計 -->
        <div class="stats-grid">
            <div class="stat-card">
                <div class="stat-number" id="completedCount">0</div>
                <div class="stat-label">完了タスク</div>
            </div>
            <div class="stat-card">
                <div class="stat-number" id="pomodoroCount">0</div>
                <div class="stat-label">総ポモドーロ</div>
            </div>
            <div class="stat-card">
                <div class="stat-number" id="wordCount">0</div>
                <div class="stat-label">執筆文字数</div>
            </div>
            <div class="stat-card">
                <div class="stat-number" id="activeStreak">0</div>
                <div class="stat-label">連続作業日数</div>
            </div>
        </div>
    </div>

    <!-- モーダル群 -->
    
    <!-- ジャンル追加/編集モーダル -->
    <div id="genreModal" class="modal">
        <div class="modal-content">
            <h3 id="genreModalTitle">新規ジャンル追加</h3>
            <input type="text" id="genreInput" placeholder="ジャンル名を入力">
            <div style="display: flex; gap: 10px; margin-top: 15px;">
                <button class="btn btn-primary" onclick="saveGenre()" style="flex: 1;">保存</button>
                <button class="btn btn-secondary" onclick="hideModal('genreModal')" style="flex: 1;">キャンセル</button>
            </div>
        </div>
    </div>

    <!-- タスク追加/編集モーダル -->
    <div id="taskModal" class="modal">
        <div class="modal-content">
            <h3 id="taskModalTitle">タスク追加</h3>
            <input type="text" id="taskTitle" placeholder="タスク名">
            <select id="taskType">
                <option value="transcript">セリフ起こし</option>
                <option value="character_analysis">キャラクター分析</option>
                <option value="world_analysis">世界観分析</option>
                <option value="plot_analysis">展開分析</option>
                <option value="planning">伏線展開ファイル</option>
                <option value="writing">夢小説執筆</option>
                <option value="other">その他</option>
            </select>
            
            <div style="margin: 10px 0;">
                <label style="color: #999; font-size: 14px;">タグ</label>
                <div class="tag-container">
                    <label style="display: flex; align-items: center; gap: 5px;">
                        <input type="checkbox" id="tagR18"> R-18
                    </label>
                    <label style="display: flex; align-items: center; gap: 5px;">
                        <input type="checkbox" id="tagRomance"> 恋愛
                    </label>
                    <label style="display: flex; align-items: center; gap: 5px;">
                        <input type="checkbox" id="tagAction"> アクション
                    </label>
                </div>
            </div>

            <div style="margin: 10px 0;">
                <label style="color: #999; font-size: 14px;">章構成（執筆タスクの場合）</label>
                <input type="number" id="chapterCount" placeholder="章数" min="1" value="3">
                <input type="number" id="wordsPerChapter" placeholder="1話あたりの文字数" min="100" value="8000">
            </div>

            <input type="date" id="taskStartDate">
            <input type="date" id="taskEndDate">
            <input type="number" id="taskPomodoros" placeholder="予定ポモドーロ数" min="1" value="4">
            <select id="taskPriority">
                <option value="high">優先度: 高</option>
                <option value="medium">優先度: 中</option>
                <option value="low">優先度: 低</option>
            </select>
            <textarea id="taskDetails" placeholder="作業詳細" rows="3"></textarea>
            
            <div style="margin: 10px 0;">
                <label style="color: #999; font-size: 14px;">サブタスク</label>
                <div id="subtaskList"></div>
                <button class="btn btn-secondary btn-small" onclick="addSubtask()">+ サブタスク追加</button>
            </div>

            <div style="display: flex; gap: 10px; margin-top: 15px;">
                <button class="btn btn-primary" onclick="saveTask()" style="flex: 1;">保存</button>
                <button class="btn btn-secondary" onclick="hideModal('taskModal')" style="flex: 1;">キャンセル</button>
            </div>
        </div>
    </div>

    <!-- タスク詳細モーダル -->
    <div id="detailModal" class="modal">
        <div class="modal-content">
            <h3 id="detailTitle">タスク詳細</h3>
            <div id="detailContent"></div>
            <div style="display: flex; gap: 10px; margin-top: 15px;">
                <button class="btn btn-primary" onclick="startDetailPomodoro()" style="flex: 1;">作業開始</button>
                <button class="btn btn-warning" onclick="editCurrentTask()" style="flex: 1;">編集</button>
                <button class="btn btn-secondary" onclick="hideModal('detailModal')" style="flex: 1;">閉じる</button>
            </div>
        </div>
    </div>

    <!-- メモモーダル -->
    <div id="memoModal" class="modal">
        <div class="modal-content">
            <h3 id="memoModalTitle">メモ追加</h3>
            <input type="text" id="memoTitle" placeholder="タイトル">
            <textarea id="memoContent" placeholder="内容" rows="10"></textarea>
            <select id="memoGenre">
                <option value="">ジャンル選択</option>
            </select>
            <div class="tag-container" style="margin-top: 10px;">
                <label><input type="checkbox" id="memoTagIdea"> アイデア</label>
                <label><input type="checkbox" id="memoTagCharacter"> キャラ設定</label>
                <label><input type="checkbox" id="memoTagPlot"> プロット</label>
            </div>
            <div style="display: flex; gap: 10px; margin-top: 15px;">
                <button class="btn btn-primary" onclick="saveMemo()" style="flex: 1;">保存</button>
                <button class="btn btn-secondary" onclick="hideModal('memoModal')" style="flex: 1;">キャンセル</button>
            </div>
        </div>
    </div>

    <script>
        // ===== データ管理 =====
        let appData = {
            tasks: {},
            genres: [],
            selectedGenre: '全体',
            pomodoroTime: 25 * 60,
            pomodoroActive: false,
            pomodoroPaused: false,
            motivationLevel: 75,
            dailyProgress: {},
            memos: [],
            weeklyGoal: '',
            habitData: {
                analysis: {},
                creation: {}
            },
            currentTaskId: null,
            currentEditGenre: null,
            currentEditTaskId: null,
            currentDetailTask: null,
            currentEditMemoId: null
        };

        let pomodoroInterval;
        const STORAGE_KEY = 'dreamNovelDashboard';
        const AUTO_SAVE_INTERVAL = 30000; // 30秒ごとに自動保存

        // ===== 初期化 =====
        function init() {
            loadData();
            
            if (appData.genres.length === 0) {
                appData.genres = ['TRICK', 'KILLERS'];
                generateInitialTasks();
            }
            
            renderGenreTabs();
            renderTasks();
            updateStats();
            updateAIAdvice();
            updateProgressSection();
            updateTodayProgress();
            renderMemos();
            renderHabitTracker();
            renderCalendar();
            loadGoal();
            
            // 自動保存設定
            setInterval(saveToLocal, AUTO_SAVE_INTERVAL);
            
            // ページ離脱時の保存
            window.addEventListener('beforeunload', saveToLocal);
        }

        // ===== データ永続化 =====
        function saveToLocal() {
            try {
                localStorage.setItem(STORAGE_KEY, JSON.stringify(appData));
                updateSyncIndicator('saved');
                console.log('データ保存完了:', new Date().toLocaleTimeString());
            } catch (e) {
                console.error('保存エラー:', e);
                updateSyncIndicator('error');
            }
        }

        function loadData() {
            try {
                const saved = localStorage.getItem(STORAGE_KEY);
                if (saved) {
                    const parsed = JSON.parse(saved);
                    appData = { ...appData, ...parsed };
                    console.log('データ読み込み完了');
                }
            } catch (e) {
                console.error('読み込みエラー:', e);
            }
        }

        function exportData() {
            const dataStr = JSON.stringify(appData, null, 2);
            const blob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `dream-novel-backup-${new Date().toISOString().split('T')[0]}.json`;
            a.click();
            URL.revokeObjectURL(url);
            showNotification('データをエクスポートしました');
        }

        function importData() {
            document.getElementById('importFile').click();
        }

        function handleImport(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const imported = JSON.parse(e.target.result);
                    appData = { ...appData, ...imported };
                    saveToLocal();
                    location.reload();
                } catch (error) {
                    showNotification('インポートに失敗しました', 'error');
                }
            };
            reader.readAsText(file);
        }

        function updateSyncIndicator(status) {
            const indicator = document.getElementById('syncIndicator');
            const icon = document.getElementById('syncIcon');
            const text = document.getElementById('syncText');
            
            if (status === 'saved') {
                icon.textContent = '✓';
                text.textContent = '保存済み';
                indicator.style.borderColor = '#4caf50';
                indicator.style.color = '#4caf50';
            } else if (status === 'syncing') {
                icon.textContent = '↻';
                text.textContent = '保存中...';
                indicator.className = 'sync-indicator syncing';
            } else if (status === 'error') {
                icon.textContent = '!';
                text.textContent = 'エラー';
                indicator.style.borderColor = '#f44336';
                indicator.style.color = '#f44336';
            }
        }

        // ===== ジャンル管理 =====
        function renderGenreTabs() {
            const container = document.getElementById('genreTabs');
            const addButton = container.querySelector('.btn-success');
            
            // 既存のタブをクリア
            container.innerHTML = '';
            
            // 全体タブ
            const allTab = document.createElement('div');
            allTab.className = appData.selectedGenre === '全体' ? 'genre-tab active' : 'genre-tab';
            allTab.textContent = '全体';
            allTab.onclick = () => selectGenre('全体');
            container.appendChild(allTab);
            
            // ジャンルをあいうえお順にソート
            const sortedGenres = [...appData.genres].sort((a, b) => a.localeCompare(b, 'ja'));
            
            sortedGenres.forEach(genre => {
                const tab = document.createElement('div');
                tab.className = appData.selectedGenre === genre ? 'genre-tab active' : 'genre-tab';
                
                // 最近作業したジャンルにキラキラマーク
                const recentWork = getGenreActivity(genre);
                if (recentWork > 5) {
                    tab.innerHTML = `<span class="sparkle">✨</span> ${genre}`;
                } else {
                    tab.textContent = genre;
                }
                
                // ジャンル操作ボタン
                const actions = document.createElement('div');
                actions.className = 'genre-actions';
                actions.innerHTML = `
                    <button class="genre-action-btn btn-warning" onclick="editGenre('${genre}'); event.stopPropagation();" title="編集">✏️</button>
                    <button class="genre-action-btn btn-danger" onclick="deleteGenre('${genre}'); event.stopPropagation();" title="削除">🗑️</button>
                `;
                tab.appendChild(actions);
                
                tab.onclick = () => selectGenre(genre);
                container.appendChild(tab);
            });
            
            // 追加ボタンを再度追加
            container.appendChild(addButton);
        }

        function getGenreActivity(genre) {
            if (!appData.tasks[genre]) return 0;
            return appData.tasks[genre].reduce((sum, task) => sum + task.pomodoroSessions, 0);
        }

        function selectGenre(genre) {
            appData.selectedGenre = genre;
            renderGenreTabs();
            renderTasks();
            saveToLocal();
        }

        function showAddGenreModal() {
            appData.currentEditGenre = null;
            document.getElementById('genreModalTitle').textContent = '新規ジャンル追加';
            document.getElementById('genreInput').value = '';
            document.getElementById('genreModal').style.display = 'flex';
        }

        function editGenre(genre) {
            appData.currentEditGenre = genre;
            document.getElementById('genreModalTitle').textContent = 'ジャンル編集';
            document.getElementById('genreInput').value = genre;
            document.getElementById('genreModal').style.display = 'flex';
        }

        function saveGenre() {
            const input = document.getElementById('genreInput').value.trim();
            
            if (!input) {
                showNotification('ジャンル名を入力してください', 'error');
                return;
            }
            
            if (appData.currentEditGenre) {
                // 編集モード
                const oldName = appData.currentEditGenre;
                const index = appData.genres.indexOf(oldName);
                if (index !== -1) {
                    appData.genres[index] = input;
                    // タスクも移行
                    if (appData.tasks[oldName]) {
                        appData.tasks[input] = appData.tasks[oldName];
                        delete appData.tasks[oldName];
                    }
                }
            } else {
                // 新規追加
                if (!appData.genres.includes(input)) {
                    appData.genres.push(input);
                    appData.tasks[input] = [];
                    generateTasksForGenre(input);
                }
            }
            
            renderGenreTabs();
            renderTasks();
            hideModal('genreModal');
            saveToLocal();
            showNotification('ジャンルを保存しました');
        }

        function deleteGenre(genre) {
            if (!confirm(`ジャンル「${genre}」を削除しますか？\n関連するタスクも全て削除されます。`)) {
                return;
            }
            
            const index = appData.genres.indexOf(genre);
            if (index !== -1) {
                appData.genres.splice(index, 1);
                delete appData.tasks[genre];
                
                if (appData.selectedGenre === genre) {
                    appData.selectedGenre = '全体';
                }
                
                renderGenreTabs();
                renderTasks();
                saveToLocal();
                showNotification('ジャンルを削除しました');
            }
        }

        // ===== タスク管理 =====
        function generateInitialTasks() {
            appData.genres.forEach(genre => {
                generateTasksForGenre(genre);
            });
        }

        function generateTasksForGenre(genre) {
            const templates = getTaskTemplates(genre);
            const today = new Date();
            let currentDate = new Date(today);
            
            appData.tasks[genre] = templates.map((template, index) => {
                const task = {
                    id: `${genre}-${Date.now()}-${index}`,
                    genre: genre,
                    ...template,
                    startDate: currentDate.toISOString().split('T')[0],
                    endDate: new Date(currentDate.getTime() + (template.duration - 1) * 24 * 60 * 60 * 1000).toISOString().split('T')[0],
                    progress: 0,
                    pomodoroSessions: 0,
                    completed: false,
                    tags: [],
                    isPriority: false
                };
                currentDate = new Date(currentDate.getTime() + template.duration * 24 * 60 * 60 * 1000);
                return task;
            });
        }

        function getTaskTemplates(genre) {
            return [
                {
                    title: `${genre} セリフ起こし`,
                    type: 'transcript',
                    duration: 2,
                    estimatedPomodoros: 8,
                    priority: 'high',
                    details: 'MakeMKV(1時間) → HandBrake(1時間) → Notta(1-2時間)',
                    subTasks: [
                        { name: 'DVD/Blu-rayのリッピング (MakeMKV)', completed: false },
                        { name: '動画形式の変換 (HandBrake)', completed: false },
                        { name: 'AI文字起こし (Notta)', completed: false },
                        { name: 'テキストの校正・整形', completed: false }
                    ]
                },
                {
                    title: `${genre} キャラクター分析`,
                    type: 'character_analysis',
                    duration: 2,
                    estimatedPomodoros: 4,
                    priority: 'medium',
                    details: 'セリフから性格特性を抽出・分析',
                    subTasks: [
                        { name: '主人公の性格・特徴分析', completed: false },
                        { name: 'サブキャラクターの役割整理', completed: false },
                        { name: 'キャラクター相関図作成', completed: false },
                        { name: '口調・話し方の特徴まとめ', completed: false }
                    ]
                },
                {
                    title: `${genre} 世界観・展開分析`,
                    type: 'world_analysis',
                    duration: 2,
                    estimatedPomodoros: 4,
                    priority: 'medium',
                    details: 'ストーリー構造と世界観の把握',
                    subTasks: [
                        { name: '時系列整理', completed: false },
                        { name: '重要な出来事のピックアップ', completed: false },
                        { name: '世界観設定の抽出', completed: false },
                        { name: '伏線・謎の整理', completed: false }
                    ]
                },
                {
                    title: `${genre} 伏線展開ファイル`,
                    type: 'planning',
                    duration: 3,
                    estimatedPomodoros: 6,
                    priority: 'high',
                    details: '3章構成の作成',
                    subTasks: [
                        { name: '全体プロット作成', completed: false },
                        { name: '第1章の構成', completed: false },
                        { name: '第2章の構成', completed: false },
                        { name: '第3章の構成', completed: false },
                        { name: '伏線の配置確認', completed: false },
                        { name: 'クライマックスの設計', completed: false }
                    ]
                },
                {
                    title: `${genre} 夢小説執筆`,
                    type: 'writing',
                    duration: 10,
                    estimatedPomodoros: 20,
                    priority: 'high',
                    details: '3章構成、1話8000字目安',
                    subTasks: [
                        { name: '第1章 第1話執筆', completed: false },
                        { name: '第1章 第2話執筆', completed: false },
                        { name: '第1章 第3話執筆', completed: false },
                        { name: '第2章 第1話執筆', completed: false },
                        { name: '第2章 第2話執筆', completed: false },
                        { name: '第2章 第3話執筆', completed: false },
                        { name: '第3章 第1話執筆', completed: false },
                        { name: '第3章 第2話執筆', completed: false },
                        { name: '第3章 第3話執筆', completed: false },
                        { name: '全体の推敲・修正', completed: false }
                    ],
                    chapters: 3,
                    wordsPerChapter: 8000
                }
            ];
        }

        function renderTasks() {
            const container = document.getElementById('taskList');
            container.innerHTML = '';
            
            const priorityTasks = [];
            const normalTasks = [];
            
            Object.entries(appData.tasks).forEach(([genre, tasks]) => {
                if (appData.selectedGenre !== '全体' && appData.selectedGenre !== genre) return;
                
                tasks.forEach(task => {
                    if (task.isPriority) {
                        priorityTasks.push(task);
                    } else {
                        normalTasks.push(task);
                    }
                });
            });
            
            // 優先タスクを先に表示
            [...priorityTasks, ...normalTasks].forEach(task => {
                const section = document.createElement('div');
                section.innerHTML = createTaskCard(task);
                container.appendChild(section);
            });
            
            // タスク追加ボタン
            if (appData.selectedGenre !== '全体') {
                const addButton = document.createElement('div');
                addButton.style.textAlign = 'center';
                addButton.style.margin = '20px 0';
                addButton.innerHTML = `
                    <button class="btn btn-success" onclick="showAddTaskModal('${appData.selectedGenre}')">
                        + ${appData.selectedGenre}にタスクを追加
                    </button>
                `;
                container.appendChild(addButton);
            }
        }

        function createTaskCard(task) {
            const isOverdue = new Date(task.endDate) < new Date() && !task.completed;
            const deadlineClass = getDeadlineClass(task.endDate);
            const isR18 = task.tags && task.tags.includes('R-18');
            
            let cardClass = 'task-card';
            if (task.completed) cardClass += ' completed';
            if (isOverdue) cardClass += ' overdue';
            if (task.isPriority) cardClass += ' priority';
            if (isR18) cardClass += ' r18';
            
            const progressPercent = calculateTaskProgress(task);
            
            return `
                <div class="${cardClass}" onclick="showTaskDetail('${task.id}')">
                    <div class="task-header">
                        <div style="display: flex; align-items: center; flex: 1;">
                            <input type="checkbox" class="checkbox" ${task.completed ? 'checked' : ''} 
                                   onclick="event.stopPropagation(); toggleTask('${task.id}')">
                            <div class="task-title">
                                ${task.isPriority ? '<span class="crown-icon">👑</span>' : ''}
                                ${task.title}
                                ${isR18 ? '<span class="tag r18" style="margin-left: 8px;">R-18</span>' : ''}
                            </div>
                        </div>
                        <div style="display: flex; align-items: center; gap: 10px;">
                            <div class="task-deadline ${deadlineClass}">
                                ${new Date(task.endDate).toLocaleDateString('ja-JP')}
                            </div>
                            <button class="btn btn-danger btn-small" onclick="event.stopPropagation(); deleteTask('${task.id}')">削除</button>
                        </div>
                    </div>
                    <div style="font-size: 12px; color: #999; margin: 5px 0;">${task.details}</div>
                    <div class="progress-bar">
                        <div class="progress-fill" style="width: ${progressPercent}%"></div>
                    </div>
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                        <span style="font-size: 12px; color: #999;">
                            🍅 ${task.pomodoroSessions}/${task.estimatedPomodoros} | 
                            進捗: ${progressPercent.toFixed(0)}%
                        </span>
                        <button class="btn btn-primary btn-small" onclick="event.stopPropagation(); startTaskPomodoro('${task.id}')">
                            ${appData.currentTaskId === task.id && appData.pomodoroActive ? '作業中' : '作業開始'}
                        </button>
                    </div>
                </div>
            `;
        }

        function calculateTaskProgress(task) {
            if (task.completed) return 100;
            
            if (task.subTasks && task.subTasks.length > 0) {
                const completedSubs = task.subTasks.filter(s => s.completed).length;
                const subProgress = (completedSubs / task.subTasks.length) * 50;
                const pomodoroProgress = Math.min(50, (task.pomodoroSessions / task.estimatedPomodoros) * 50);
                return subProgress + pomodoroProgress;
            }
            
            return Math.min(100, (task.pomodoroSessions / task.estimatedPomodoros) * 100);
        }

        function getDeadlineClass(endDate) {
            const today = new Date();
            const deadline = new Date(endDate);
            const daysLeft = Math.ceil((deadline - today) / (1000 * 60 * 60 * 24));
            
            if (daysLeft < 0) return 'deadline-overdue';
            if (daysLeft <= 2) return 'deadline-urgent';
            if (daysLeft <= 5) return 'deadline-soon';
            return 'deadline-normal';
        }

        function showAddTaskModal(genre) {
            appData.currentEditGenre = genre;
            appData.currentEditTaskId = null;
            
            document.getElementById('taskModalTitle').textContent = `${genre} - タスク追加`;
            document.getElementById('taskModal').style.display = 'flex';
            
            // フォームをリセット
            document.getElementById('taskTitle').value = '';
            document.getElementById('taskType').value = 'transcript';
            document.getElementById('taskDetails').value = '';
            document.getElementById('chapterCount').value = '3';
            document.getElementById('wordsPerChapter').value = '8000';
            document.getElementById('tagR18').checked = false;
            document.getElementById('tagRomance').checked = false;
            document.getElementById('tagAction').checked = false;
            
            const today = new Date().toISOString().split('T')[0];
            document.getElementById('taskStartDate').value = today;
            document.getElementById('taskEndDate').value = today;
            
            // サブタスクリストをリセット
            renderSubtasks([]);
        }

        function showTaskDetail(taskId) {
            const task = findTask(taskId);
            if (!task) return;
            
            appData.currentDetailTask = task;
            document.getElementById('detailTitle').textContent = task.title;
            
            const progressPercent = calculateTaskProgress(task);
            const content = document.getElementById('detailContent');
            
            content.innerHTML = `
                <div style="margin-bottom: 15px;">
                    <strong>ジャンル:</strong> ${task.genre}<br>
                    <strong>期間:</strong> ${task.startDate} 〜 ${task.endDate}<br>
                    <strong>進捗:</strong> ${progressPercent.toFixed(0)}%<br>
                    <strong>ポモドーロ:</strong> ${task.pomodoroSessions}/${task.estimatedPomodoros}
                    ${task.tags && task.tags.length > 0 ? `<br><strong>タグ:</strong> ${task.tags.join(', ')}` : ''}
                </div>
                <div style="background: rgba(255,255,255,0.05); padding: 10px; border-radius: 5px; margin-bottom: 15px;">
                    <strong>作業詳細:</strong><br>
                    ${task.details}
                </div>
                ${task.subTasks ? `
                    <div class="subtasks-container">
                        <strong>サブタスク:</strong>
                        ${task.subTasks.map((sub, idx) => `
                            <div class="subtask-item ${sub.completed ? 'completed' : ''}">
                                <input type="checkbox" class="subtask-checkbox" 
                                       ${sub.completed ? 'checked' : ''}
                                       onchange="toggleSubtask('${task.id}', ${idx})">
                                <span>${sub.name}</span>
                            </div>
                        `).join('')}
                    </div>
                ` : ''}
            `;
            
            document.getElementById('detailModal').style.display = 'flex';
        }

        function editCurrentTask() {
            if (!appData.currentDetailTask) return;
            
            const task = appData.currentDetailTask;
            appData.currentEditTaskId = task.id;
            appData.currentEditGenre = task.genre;
            
            document.getElementById('taskModalTitle').textContent = 'タスク編集';
            document.getElementById('taskTitle').value = task.title;
            document.getElementById('taskType').value = task.type;
            document.getElementById('taskStartDate').value = task.startDate;
            document.getElementById('taskEndDate').value = task.endDate;
            document.getElementById('taskPomodoros').value = task.estimatedPomodoros;
            document.getElementById('taskPriority').value = task.priority;
            document.getElementById('taskDetails').value = task.details;
            
            // タグの復元
            if (task.tags) {
                document.getElementById('tagR18').checked = task.tags.includes('R-18');
                document.getElementById('tagRomance').checked = task.tags.includes('恋愛');
                document.getElementById('tagAction').checked = task.tags.includes('アクション');
            }
            
            // 章構成の復元
            if (task.chapters) {
                document.getElementById('chapterCount').value = task.chapters;
                document.getElementById('wordsPerChapter').value = task.wordsPerChapter || 8000;
            }
            
            // サブタスクの復元
            renderSubtasks(task.subTasks || []);
            
            hideModal('detailModal');
            document.getElementById('taskModal').style.display = 'flex';
        }

        function saveTask() {
            const title = document.getElementById('taskTitle').value.trim();
            if (!title) {
                showNotification('タスク名を入力してください', 'error');
                return;
            }
            
            const tags = [];
            if (document.getElementById('tagR18').checked) tags.push('R-18');
            if (document.getElementById('tagRomance').checked) tags.push('恋愛');
            if (document.getElementById('tagAction').checked) tags.push('アクション');
            
            const subtasks = [];
            document.querySelectorAll('.subtask-input').forEach(input => {
                const value = input.value.trim();
                if (value) {
                    subtasks.push({ name: value, completed: false });
                }
            });
            
            const taskData = {
                title: title,
                type: document.getElementById('taskType').value,
                startDate: document.getElementById('taskStartDate').value,
                endDate: document.getElementById('taskEndDate').value,
                estimatedPomodoros: parseInt(document.getElementById('taskPomodoros').value),
                priority: document.getElementById('taskPriority').value,
                details: document.getElementById('taskDetails').value,
                tags: tags,
                subTasks: subtasks,
                chapters: parseInt(document.getElementById('chapterCount').value),
                wordsPerChapter: parseInt(document.getElementById('wordsPerChapter').value)
            };
            
            if (appData.currentEditTaskId) {
                // 編集モード
                const task = findTask(appData.currentEditTaskId);
                if (task) {
                    Object.assign(task, taskData);
                }
            } else {
                // 新規追加
                const newTask = {
                    id: `${appData.currentEditGenre}-${Date.now()}`,
                    genre: appData.currentEditGenre,
                    ...taskData,
                    progress: 0,
                    pomodoroSessions: 0,
                    completed: false,
                    isPriority: false
                };
                
                if (!appData.tasks[appData.currentEditGenre]) {
                    appData.tasks[appData.currentEditGenre] = [];
                }
                appData.tasks[appData.currentEditGenre].push(newTask);
            }
            
            renderTasks();
            updateStats();
            updateAIAdvice();
            hideModal('taskModal');
            saveToLocal();
            showNotification('タスクを保存しました');
        }

        function deleteTask(taskId) {
            if (!confirm('このタスクを削除しますか？')) return;
            
            Object.keys(appData.tasks).forEach(genre => {
                appData.tasks[genre] = appData.tasks[genre].filter(task => task.id !== taskId);
            });
            
            renderTasks();
            updateStats();
            saveToLocal();
            showNotification('タスクを削除しました');
        }

        function toggleTask(taskId) {
            const task = findTask(taskId);
            if (!task) return;
            
            task.completed = !task.completed;
            if (task.completed) {
                task.progress = 100;
                appData.motivationLevel = Math.min(100, appData.motivationLevel + 10);
                updateMotivation();
                showNotification('タスク完了！おめでとうございます！🎉');
                
                // 習慣トラッカー更新
                const today = new Date().toISOString().split('T')[0];
                if (task.type.includes('analysis')) {
                    appData.habitData.analysis[today] = true;
                } else if (task.type === 'writing' || task.type === 'planning') {
                    appData.habitData.creation[today] = true;
                }
            }
            
            renderTasks();
            updateStats();
            updateProgressSection();
            renderHabitTracker();
            saveToLocal();
        }

        function toggleSubtask(taskId, subIndex) {
            const task = findTask(taskId);
            if (!task || !task.subTasks) return;
            
            task.subTasks[subIndex].completed = !task.subTasks[subIndex].completed;
            
            renderTasks();
            updateStats();
            saveToLocal();
        }

        function renderSubtasks(subtasks) {
            const container = document.getElementById('subtaskList');
            container.innerHTML = '';
            
            subtasks.forEach((subtask, index) => {
                const div = document.createElement('div');
                div.style.marginBottom = '5px';
                div.innerHTML = `
                    <input type="text" class="subtask-input" value="${subtask.name}" placeholder="サブタスク名">
                    <button class="btn btn-danger btn-small" onclick="removeSubtaskInput(this)">削除</button>
                `;
                container.appendChild(div);
            });
        }

        function addSubtask() {
            const container = document.getElementById('subtaskList');
            const div = document.createElement('div');
            div.style.marginBottom = '5px';
            div.innerHTML = `
                <input type="text" class="subtask-input" placeholder="サブタスク名">
                <button class="btn btn-danger btn-small" onclick="removeSubtaskInput(this)">削除</button>
            `;
            container.appendChild(div);
        }

        function removeSubtaskInput(button) {
            button.parentElement.remove();
        }

        function findTask(taskId) {
            for (const genre in appData.tasks) {
                const task = appData.tasks[genre].find(t => t.id === taskId);
                if (task) return task;
            }
            return null;
        }

        function startTaskPomodoro(taskId) {
            appData.currentTaskId = taskId;
            if (!appData.pomodoroActive) {
                togglePomodoro();
            }
            showNotification('作業を開始しました');
        }

        function startDetailPomodoro() {
            if (appData.currentDetailTask) {
                startTaskPomodoro(appData.currentDetailTask.id);
                hideModal('detailModal');
            }
        }

        // ===== ポモドーロタイマー =====
        function togglePomodoro() {
            if (appData.pomodoroPaused) {
                resumePomodoro();
            } else if (appData.pomodoroActive) {
                pausePomodoro();
            } else {
                startPomodoro();
            }
        }

        function startPomodoro() {
            appData.pomodoroActive = true;
            appData.pomodoroPaused = false;
            document.getElementById('pomodoroToggle').textContent = '停止';
            pomodoroInterval = setInterval(updatePomodoro, 1000);
        }

        function pausePomodoro() {
            appData.pomodoroPaused = true;
            clearInterval(pomodoroInterval);
            document.getElementById('pomodoroToggle').textContent = '再開';
            showNotification('ポモドーロを一時停止しました');
        }

        function resumePomodoro() {
            appData.pomodoroPaused = false;
            document.getElementById('pomodoroToggle').textContent = '停止';
            pomodoroInterval = setInterval(updatePomodoro, 1000);
            showNotification('ポモドーロを再開しました');
        }

        function resetPomodoro() {
            clearInterval(pomodoroInterval);
            appData.pomodoroTime = 25 * 60;
            appData.pomodoroActive = false;
            appData.pomodoroPaused = false;
            document.getElementById('pomodoroToggle').textContent = '開始';
            updatePomodoroDisplay();
            showNotification('ポモドーロをリセットしました');
        }

        function updatePomodoro() {
            if (appData.pomodoroTime > 0) {
                appData.pomodoroTime--;
                updatePomodoroDisplay();
            } else {
                completePomodoro();
            }
        }

        function updatePomodoroDisplay() {
            const minutes = Math.floor(appData.pomodoroTime / 60);
            const seconds = appData.pomodoroTime % 60;
            document.getElementById('pomodoroTime').textContent = 
                `${minutes}:${seconds.toString().padStart(2, '0')}`;
        }

        function completePomodoro() {
            clearInterval(pomodoroInterval);
            appData.pomodoroActive = false;
            appData.pomodoroPaused = false;
            appData.pomodoroTime = 25 * 60;
            document.getElementById('pomodoroToggle').textContent = '開始';
            
            // 進捗更新
            const today = new Date().toISOString().split('T')[0];
            if (!appData.dailyProgress[today]) {
                appData.dailyProgress[today] = 0;
            }
            appData.dailyProgress[today]++;
            
            // タスクの進捗更新
            if (appData.currentTaskId) {
                const task = findTask(appData.currentTaskId);
                if (task) {
                    task.pomodoroSessions++;
                }
            }
            
            appData.motivationLevel = Math.min(100, appData.motivationLevel + 5);
            updateMotivation();
            updateTodayProgress();
            renderTasks();
            updateStats();
            updateProgressSection();
            saveToLocal();
            
            showNotification('🎉 ポモドーロ完了！5分休憩してください');
        }

        // ===== 進捗・統計 =====
        function updateProgressSection() {
            const activeTasks = [];
            Object.values(appData.tasks).forEach(genreTasks => {
                genreTasks.forEach(task => {
                    if (!task.completed && task.pomodoroSessions > 0) {
                        activeTasks.push(task);
                    }
                });
            });
            
            const focusElement = document.getElementById('currentFocus');
            if (activeTasks.length > 0) {
                const mostActive = activeTasks.sort((a, b) => b.pomodoroSessions - a.pomodoroSessions)[0];
                focusElement.innerHTML = `🔥 現在注力中: <strong>${mostActive.title}</strong> (${mostActive.pomodoroSessions}ポモドーロ実施)`;
            } else {
                focusElement.innerHTML = '📝 まだタスクを開始していません';
            }
            
            const progressBars = document.getElementById('genreProgressBars');
            progressBars.innerHTML = '';
            
            Object.entries(appData.tasks).forEach(([genre, genreTasks]) => {
                const total = genreTasks.length;
                const completed = genreTasks.filter(t => t.completed).length;
                const percentage = total > 0 ? (completed / total * 100) : 0;
                
                progressBars.innerHTML += `
                    <div style="margin: 10px 0;">
                        <div style="display: flex; justify-content: space-between; margin-bottom: 5px;">
                            <span>${genre}</span>
                            <span>${completed}/${total} 完了 (${percentage.toFixed(0)}%)</span>
                        </div>
                        <div class="progress-bar">
                            <div class="progress-fill" style="width: ${percentage}%"></div>
                        </div>
                    </div>
                `;
            });
        }

        function updateTodayProgress() {
            const today = new Date().toISOString().split('T')[0];
            const todayCount = appData.dailyProgress[today] || 0;
            
            document.getElementById('todayCount').textContent = todayCount;
            
            const dots = document.querySelectorAll('.pomodoro-dot');
            dots.forEach((dot, index) => {
                if (index < todayCount) {
                    dot.classList.add('filled');
                } else {
                    dot.classList.remove('filled');
                }
            });
        }

        function updateStats() {
            let completed = 0;
            let pomodoros = 0;
            let words = 0;
            
            Object.values(appData.tasks).forEach(genreTasks => {
                genreTasks.forEach(task => {
                    if (task.completed) completed++;
                    pomodoros += task.pomodoroSessions;
                    if (task.type === 'writing' && task.completed) {
                        const chapters = task.chapters || 3;
                        const wordsPerChapter = task.wordsPerChapter || 8000;
                        words += chapters * wordsPerChapter * 3; // 3話per章
                    }
                });
            });
            
            document.getElementById('completedCount').textContent = completed;
            document.getElementById('pomodoroCount').textContent = pomodoros;
            document.getElementById('wordCount').textContent = words.toLocaleString();
            
            // 連続作業日数
            const streak = calculateStreak();
            document.getElementById('activeStreak').textContent = streak;
        }

        function calculateStreak() {
            const dates = Object.keys(appData.dailyProgress).sort();
            if (dates.length === 0) return 0;
            
            let streak = 0;
            const today = new Date();
            today.setHours(0, 0, 0, 0);
            
            for (let i = 0; i <= 30; i++) {
                const checkDate = new Date(today);
                checkDate.setDate(today.getDate() - i);
                const dateStr = checkDate.toISOString().split('T')[0];
                
                if (appData.dailyProgress[dateStr] && appData.dailyProgress[dateStr] > 0) {
                    streak++;
                } else if (i > 0) {
                    break;
                }
            }
            
            return streak;
        }

        function updateMotivation() {
            document.getElementById('motivationBar').style.width = `${appData.motivationLevel}%`;
            let text = '';
            if (appData.motivationLevel >= 90) text = '🔥 絶好調！';
            else if (appData.motivationLevel >= 70) text = '⭐ いい感じ！';
            else if (appData.motivationLevel >= 50) text = '💖 その調子！';
            else text = '☕ 休憩も大切';
            document.getElementById('motivationText').textContent = `${text} ${appData.motivationLevel}%`;
        }

        // ===== AIアドバイス =====
        function updateAIAdvice() {
            const allTasks = [];
            Object.values(appData.tasks).forEach(genreTasks => {
                genreTasks.forEach(task => {
                    if (!task.completed) {
                        allTasks.push(task);
                    }
                });
            });
            
            const sortedTasks = allTasks.sort((a, b) => {
                const scoreA = calculatePriority(a);
                const scoreB = calculatePriority(b);
                return scoreB - scoreA;
            });
            
            const advice = document.getElementById('aiAdvice');
            if (sortedTasks.length > 0) {
                const topTasks = sortedTasks.slice(0, 3);
                
                // 優先タスクフラグを更新
                Object.values(appData.tasks).forEach(genreTasks => {
                    genreTasks.forEach(task => {
                        task.isPriority = topTasks.includes(task);
                    });
                });
                
                advice.innerHTML = topTasks.map((task, index) => `
                    <div class="ai-advice-item" onclick="scrollToTask('${task.id}')">
                        <span class="crown-icon">👑</span>
                        <strong>#${index + 1}</strong> 
                        <span style="color: #667eea;">[${task.genre}]</span>
                        ${task.title}
                        <span style="font-size: 12px; color: #999; margin-left: auto;">
                            期限: ${new Date(task.endDate).toLocaleDateString('ja-JP')}
                        </span>
                    </div>
                `).join('');
            } else {
                advice.innerHTML = '<div style="text-align: center; color: #999;">すべてのタスクが完了しています！🎉</div>';
            }
        }

        function calculatePriority(task) {
            const today = new Date();
            const deadline = new Date(task.endDate);
            const daysLeft = Math.ceil((deadline - today) / (1000 * 60 * 60 * 24));
            
            let score = 0;
            if (daysLeft < 0) score += 100;
            else if (daysLeft <= 2) score += 80;
            else if (daysLeft <= 5) score += 50;
            else if (daysLeft <= 10) score += 20;
            
            if (task.priority === 'high') score += 40;
            else if (task.priority === 'medium') score += 20;
            
            // 進捗が少ないタスクを優先
            const progress = calculateTaskProgress(task);
            if (progress < 30) score += 20;
            
            return score;
        }

        function scrollToTask(taskId) {
            const task = findTask(taskId);
            if (task) {
                appData.selectedGenre = task.genre;
                renderGenreTabs();
                renderTasks();
                
                // タスクカードまでスクロール
                setTimeout(() => {
                    const cards = document.querySelectorAll('.task-card');
                    cards.forEach(card => {
                        if (card.innerHTML.includes(taskId)) {
                            card.scrollIntoView({ behavior: 'smooth', block: 'center' });
                            card.style.animation = 'pulse 1s';
                        }
                    });
                }, 100);
            }
        }

        // ===== メモ機能 =====
        function showMemoModal(memoId = null) {
            appData.currentEditMemoId = memoId;
            
            // ジャンル選択肢を更新
            const genreSelect = document.getElementById('memoGenre');
            genreSelect.innerHTML = '<option value="">ジャンル選択</option>';
            appData.genres.forEach(genre => {
                genreSelect.innerHTML += `<option value="${genre}">${genre}</option>`;
            });
            
            if (memoId) {
                const memo = appData.memos.find(m => m.id === memoId);
                if (memo) {
                    document.getElementById('memoModalTitle').textContent = 'メモ編集';
                    document.getElementById('memoTitle').value = memo.title;
                    document.getElementById('memoContent').value = memo.content;
                    document.getElementById('memoGenre').value = memo.genre || '';
                    document.getElementById('memoTagIdea').checked = memo.tags && memo.tags.includes('idea');
                    document.getElementById('memoTagCharacter').checked = memo.tags && memo.tags.includes('character');
                    document.getElementById('memoTagPlot').checked = memo.tags && memo.tags.includes('plot');
                }
            } else {
                document.getElementById('memoModalTitle').textContent = 'メモ追加';
                document.getElementById('memoTitle').value = '';
                document.getElementById('memoContent').value = '';
                document.getElementById('memoGenre').value = appData.selectedGenre !== '全体' ? appData.selectedGenre : '';
                document.getElementById('memoTagIdea').checked = false;
                document.getElementById('memoTagCharacter').checked = false;
                document.getElementById('memoTagPlot').checked = false;
            }
            
            document.getElementById('memoModal').style.display = 'flex';
        }

        function saveMemo() {
            const title = document.getElementById('memoTitle').value.trim();
            const content = document.getElementById('memoContent').value.trim();
            
            if (!title || !content) {
                showNotification('タイトルと内容を入力してください', 'error');
                return;
            }
            
            const tags = [];
            if (document.getElementById('memoTagIdea').checked) tags.push('idea');
            if (document.getElementById('memoTagCharacter').checked) tags.push('character');
            if (document.getElementById('memoTagPlot').checked) tags.push('plot');
            
            const memoData = {
                title: title,
                content: content,
                genre: document.getElementById('memoGenre').value,
                tags: tags,
                date: new Date().toISOString()
            };
            
            if (appData.currentEditMemoId) {
                const index = appData.memos.findIndex(m => m.id === appData.currentEditMemoId);
                if (index !== -1) {
                    appData.memos[index] = { ...appData.memos[index], ...memoData };
                }
            } else {
                const newMemo = {
                    id: Date.now(),
                    ...memoData
                };
                appData.memos.unshift(newMemo);
            }
            
            renderMemos();
            hideModal('memoModal');
            saveToLocal();
            showNotification('メモを保存しました');
        }

        function renderMemos() {
            const container = document.getElementById('memoList');
            if (!container) return;
            
            if (appData.memos.length === 0) {
                container.innerHTML = '<div style="text-align: center; color: #999; padding: 20px;">メモがありません</div>';
                return;
            }
            
            container.innerHTML = appData.memos.map(memo => `
                <div class="memo-item" id="memo-${memo.id}" onclick="toggleMemo(${memo.id})">
                    <div class="memo-title">
                        ${memo.title}
                        ${memo.genre ? `<span style="color: #667eea; font-size: 12px; margin-left: 10px;">[${memo.genre}]</span>` : ''}
                    </div>
                    <div class="memo-preview">${memo.content}</div>
                    <div class="memo-content">${memo.content}</div>
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-top: 10px;">
                        <div class="tag-container">
                            ${memo.tags ? memo.tags.map(tag => `<span class="tag">${tag}</span>`).join('') : ''}
                        </div>
                        <div style="display: flex; gap: 10px;">
                            <span style="color: #999; font-size: 12px;">
                                ${new Date(memo.date).toLocaleDateString('ja-JP')}
                            </span>
                            <button class="btn btn-warning btn-small" onclick="event.stopPropagation(); showMemoModal(${memo.id})">編集</button>
                            <button class="btn btn-danger btn-small" onclick="event.stopPropagation(); deleteMemo(${memo.id})">削除</button>
                        </div>
                    </div>
                </div>
            `).join('');
        }

        function toggleMemo(memoId) {
            const memoElement = document.getElementById(`memo-${memoId}`);
            if (memoElement) {
                memoElement.classList.toggle('expanded');
            }
        }

        function deleteMemo(memoId) {
            if (!confirm('このメモを削除しますか？')) return;
            
            appData.memos = appData.memos.filter(m => m.id !== memoId);
            renderMemos();
            saveToLocal();
            showNotification('メモを削除しました');
        }

        // ===== 習慣トラッカー =====
        function renderHabitTracker() {
            const today = new Date();
            const days = 7;
            
            ['analysis', 'creation'].forEach(type => {
                const container = document.getElementById(`${type}Habit`);
                container.innerHTML = '';
                
                for (let i = days - 1; i >= 0; i--) {
                    const date = new Date(today);
                    date.setDate(today.getDate() - i);
                    const dateStr = date.toISOString().split('T')[0];
                    const isCompleted = appData.habitData[type][dateStr];
                    
                    const cell = document.createElement('div');
                    cell.className = `habit-cell ${isCompleted ? 'completed' : ''}`;
                    cell.textContent = date.getDate();
                    cell.title = dateStr;
                    cell.onclick = () => toggleHabit(type, dateStr);
                    
                    container.appendChild(cell);
                }
            });
        }

        function toggleHabit(type, dateStr) {
            if (!appData.habitData[type][dateStr]) {
                appData.habitData[type][dateStr] = true;
            } else {
                delete appData.habitData[type][dateStr];
            }
            renderHabitTracker();
            saveToLocal();
        }

        // ===== カレンダー =====
        function toggleCalendarView() {
            const calendar = document.getElementById('calendarView');
            if (calendar.style.display === 'none') {
                calendar.style.display = 'block';
                renderCalendar();
            } else {
                calendar.style.display = 'none';
            }
        }

        function renderCalendar() {
            const container = document.getElementById('calendarGrid');
            const today = new Date();
            const year = today.getFullYear();
            const month = today.getMonth();
            const firstDay = new Date(year, month, 1);
            const lastDay = new Date(year, month + 1, 0);
            const daysInMonth = lastDay.getDate();
            
            container.innerHTML = '';
            
            // 曜日ヘッダー
            const weekDays = ['日', '月', '火', '水', '木', '金', '土'];
            weekDays.forEach(day => {
                const header = document.createElement('div');
                header.style.fontWeight = 'bold';
                header.style.textAlign = 'center';
                header.style.color = '#999';
                header.textContent = day;
                container.appendChild(header);
            });
            
            // 月初の空白
            for (let i = 0; i < firstDay.getDay(); i++) {
                container.appendChild(document.createElement('div'));
            }
            
            // 日付
            for (let day = 1; day <= daysInMonth; day++) {
                const date = new Date(year, month, day);
                const dateStr = date.toISOString().split('T')[0];
                const isToday = day === today.getDate();
                
                // その日のタスク数を計算
                let taskCount = 0;
                Object.values(appData.tasks).forEach(genreTasks => {
                    genreTasks.forEach(task => {
                        const start = new Date(task.startDate);
                        const end = new Date(task.endDate);
                        if (date >= start && date <= end && !task.completed) {
                            taskCount++;
                        }
                    });
                });
                
                const cell = document.createElement('div');
                cell.className = `calendar-day ${isToday ? 'today' : ''} ${taskCount > 0 ? 'has-tasks' : ''}`;
                cell.innerHTML = `
                    <div class="calendar-day-number">${day}</div>
                    ${taskCount > 0 ? `<div class="calendar-day-tasks">${taskCount}件</div>` : ''}
                    ${appData.dailyProgress[dateStr] ? `<div style="color: #ff6b6b; font-size: 10px;">🍅${appData.dailyProgress[dateStr]}</div>` : ''}
                `;
                
                container.appendChild(cell);
            }
        }

        // ===== 週間目標 =====
        function saveGoal() {
            appData.weeklyGoal = document.getElementById('weeklyGoal').value;
            saveToLocal();
            showNotification('目標を保存しました');
        }

        function loadGoal() {
            if (appData.weeklyGoal) {
                document.getElementById('weeklyGoal').value = appData.weeklyGoal;
            }
            updateGoalProgress();
        }

        function updateGoalProgress() {
            const progress = document.getElementById('goalProgress');
            if (!appData.weeklyGoal) {
                progress.textContent = '';
                return;
            }
            
            // 今週の完了タスク数を計算
            const thisWeek = getThisWeekDates();
            let completedThisWeek = 0;
            
            Object.values(appData.tasks).forEach(genreTasks => {
                genreTasks.forEach(task => {
                    if (task.completed) {
                        // タスクの完了日を推定（簡易的に終了日を使用）
                        if (thisWeek.includes(task.endDate)) {
                            completedThisWeek++;
                        }
                    }
                });
            });
            
            progress.innerHTML = `今週の完了: ${completedThisWeek}件`;
        }

        function getThisWeekDates() {
            const dates = [];
            const today = new Date();
            const dayOfWeek = today.getDay();
            
            for (let i = 0; i < 7; i++) {
                const date = new Date(today);
                date.setDate(today.getDate() - dayOfWeek + i);
                dates.push(date.toISOString().split('T')[0]);
            }
            
            return dates;
        }

        // ===== ユーティリティ =====
        function hideModal(modalId) {
            document.getElementById(modalId).style.display = 'none';
        }

        function showNotification(message, type = 'success') {
            const notification = document.createElement('div');
            notification.className = 'notification';
            if (type === 'error') {
                notification.style.background = 'linear-gradient(135deg, #f56565 0%, #e53e3e 100%)';
            }
            notification.textContent = message;
            document.body.appendChild(notification);
            
            setTimeout(() => {
                notification.style.animation = 'slideOut 0.5s ease';
                setTimeout(() => notification.remove(), 500);
            }, 3000);
        }

        @keyframes slideOut {
            to {
                transform: translateX(120%);
                opacity: 0;
            }
        }

        // 初期化実行
        window.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>
