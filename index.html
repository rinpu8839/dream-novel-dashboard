completed: false
};
currentDate = new Date(currentDate.getTime() + template.duration * 24 * 60 * 60 * 1000);
return task;
});
}

// タスク表示
function renderTasks() {
const taskList = document.getElementById('taskList');
taskList.innerHTML = '';

Object.entries(tasks).forEach(([genre, genreTasks]) => {
if (selectedGenre !== '全体' && selectedGenre !== genre) return;

const genreSection = document.createElement('div');
genreSection.innerHTML = `
<div style="display: flex; justify-content: space-between; align-items: center; margin: 15px 0;">
<h3 style="color: white;">${genre}</h3>
<button class="btn btn-success btn-small" onclick="showAddTaskModal('${genre}')">
+ タスク追加
</button>
</div>
`;

genreTasks.forEach(task => {
const taskCard = createTaskCard(task);
genreSection.appendChild(taskCard);
});

taskList.appendChild(genreSection);
});
}

// タスクカード作成
function createTaskCard(task) {
const card = document.createElement('div');
const isOverdue = new Date(task.endDate) < new Date() && !task.completed;
card.className = `task-card ${task.completed ? 'completed' : ''} ${isOverdue ? 'overdue' : ''}`;

const deadlineClass = getDeadlineClass(task.endDate);
const deadlineText = new Date(task.endDate).toLocaleDateString('ja-JP');

card.innerHTML = `
<div class="task-header">
    <!-- バックアップ・復元ボタン -->
<div style="margin-top: 15px; display: flex; gap: 10px; flex-wrap: wrap;">
    <button class="btn btn-warning" onclick="exportBackup()">
        💾 バックアップ保存
    </button>
    <button class="btn btn-success" onclick="importBackup()">
        📂 バックアップ読込
    </button>
    <div style="font-size: 12px; color: #666; width: 100%; margin-top: 5px;">
        ※ 定期的にバックアップを取ることをお勧めします
    </div>
</div>
<div style="display: flex; align-items: center; flex: 1;">
<input type="checkbox" class="checkbox" ${task.completed ? 'checked' : ''}
onchange="toggleTask('${task.id}')">
<div class="task-title" onclick="showTaskDetail('${task.id}')">${task.title}</div>
</div>
<div style="display: flex; align-items: center; gap: 10px;">
<div class="task-deadline ${deadlineClass}">${deadlineText}</div>
<div class="task-actions">
<button class="btn btn-danger btn-small" onclick="deleteTask('${task.id}')">削除</button>
</div>
</div>
</div>
<div style="font-size: 12px; color: #666; margin: 5px 0;">${task.details}</div>
<div class="progress-bar">
<div class="progress-fill" style="width: ${task.progress}%"></div>
</div>
<div style="display: flex; justify-content: space-between; align-items: center;">
<span style="font-size: 12px;">🍅 ${task.pomodoroSessions}/${task.estimatedPomodoros}</span>
<button class="btn btn-primary btn-small" onclick="startTaskPomodoro('${task.id}')">
${currentTaskId === task.id && pomodoroActive ? '作業中' : '作業開始'}
</button>
</div>
`;

return card;
}

// 期限クラス判定
function getDeadlineClass(endDate) {
const today = new Date();
const deadline = new Date(endDate);
const daysLeft = Math.ceil((deadline - today) / (1000 * 60 * 60 * 24));

if (daysLeft < 0) return 'deadline-overdue';
if (daysLeft <= 2) return 'deadline-urgent';
if (daysLeft <= 5) return 'deadline-soon';
return 'deadline-normal';
}

// 期限切れタスクチェック
function checkOverdueTasks() {
const overdueTasks = [];
Object.values(tasks).forEach(genreTasks => {
genreTasks.forEach(task => {
if (new Date(task.endDate) < new Date() && !task.completed) {
overdueTasks.push(task);
}
});
});

if (overdueTasks.length > 0) {
document.getElementById('overdueAlert').style.display = 'block';
document.getElementById('overdueList').innerHTML = overdueTasks.map(task =>
`<div style="margin: 5px 0;">• ${task.title} (${new Date(task.endDate).toLocaleDateString('ja-JP')}期限)</div>`
).join('');
} else {
document.getElementById('overdueAlert').style.display = 'none';
}
}

// 期限再設定
function rescheduleOverdue() {
const today = new Date();
Object.keys(tasks).forEach(genre => {
tasks[genre] = tasks[genre].map(task => {
if (new Date(task.endDate) < today && !task.completed) {
// 今日から同じ期間で再設定
const duration = Math.ceil((new Date(task.endDate) - new Date(task.startDate)) / (1000 * 60 * 60 * 24));
task.startDate = today.toISOString().split('T')[0];
task.endDate = new Date(today.getTime() + duration * 24 * 60 * 60 * 1000).toISOString().split('T')[0];
}
return task;
});
});
renderTasks();
checkOverdueTasks();
alert('期限を再設定しました！新しい期限で頑張りましょう！');
}

// 進捗状況更新
function updateProgressSection() {
// 現在の注力タスク
const activeTasks = [];
Object.values(tasks).forEach(genreTasks => {
genreTasks.forEach(task => {
if (!task.completed && task.pomodoroSessions > 0) {
activeTasks.push(task);
}
});
});

const focusElement = document.getElementById('currentFocus');
if (activeTasks.length > 0) {
const mostActive = activeTasks.sort((a, b) => b.pomodoroSessions - a.pomodoroSessions)[0];
focusElement.innerHTML = `🔥 現在注力中: <strong>${mostActive.title}</strong> (${mostActive.pomodoroSessions}ポモドーロ実施)`;
} else {
focusElement.innerHTML = '📝 まだタスクを開始していません';
}

// ジャンル別進捗
const progressBars = document.getElementById('genreProgressBars');
progressBars.innerHTML = '';

Object.entries(tasks).forEach(([genre, genreTasks]) => {
const total = genreTasks.length;
const completed = genreTasks.filter(t => t.completed).length;
const percentage = total > 0 ? (completed / total * 100) : 0;

progressBars.innerHTML += `
<div class="genre-progress">
<div style="display: flex; justify-content: space-between;">
<span>${genre}</span>
<span>${completed}/${total} 完了</span>
</div>
<div class="genre-progress-bar">
<div class="genre-progress-fill" style="width: ${percentage}%"></div>
</div>
</div>
`;
});
}

// タスク詳細表示
function showTaskDetail(taskId) {
let task = null;
Object.values(tasks).forEach(genreTasks => {
const found = genreTasks.find(t => t.id === taskId);
if (found) task = found;
});

if (!task) return;

currentDetailTask = task;
document.getElementById('detailTitle').textContent = task.title;

const content = document.getElementById('detailContent');
content.innerHTML = `
<div style="margin-bottom: 15px;">
<strong>期間:</strong> ${task.startDate} 〜 ${task.endDate}<br>
<strong>進捗:</strong> ${Math.round(task.progress)}%<br>
<strong>ポモドーロ:</strong> ${task.pomodoroSessions}/${task.estimatedPomodoros}
</div>
<div style="background: #f5f5f5; padding: 10px; border-radius: 5px; margin-bottom: 15px;">
<strong>作業詳細:</strong><br>
${task.details}
</div>
${task.subTasks ? `
<div>
<strong>サブタスク:</strong>
${task.subTasks.map((sub, idx) => `
<div class="subtask-item">
<input type="checkbox" class="subtask-checkbox"
${sub.completed ? 'checked' : ''}
onchange="toggleSubtask('${task.id}', ${idx})">
<span>${sub.name}</span>
</div>
`).join('')}
</div>
` : ''}
`;

// ランダムな励ましの言葉
const randomQuote = quotes[Math.floor(Math.random() * quotes.length)];
document.getElementById('motivationalQuote').textContent = `"${randomQuote}"`;

document.getElementById('detailModal').style.display = 'flex';
}

// サブタスク切り替え
function toggleSubtask(taskId, subIndex) {
Object.keys(tasks).forEach(genre => {
tasks[genre] = tasks[genre].map(task => {
if (task.id === taskId && task.subTasks) {
task.subTasks[subIndex].completed = !task.subTasks[subIndex].completed;
// サブタスクの完了状況から進捗を計算
const completedSubs = task.subTasks.filter(s => s.completed).length;
task.progress = Math.max(task.progress, (completedSubs / task.subTasks.length) * 50);
}
return task;
});
});
updateStats();
}

// 詳細からポモドーロ開始
function startDetailPomodoro() {
if (currentDetailTask) {
startTaskPomodoro(currentDetailTask.id);
hideModal('detailModal');
}
}

// タスク追加モーダル表示
function showAddTaskModal(genre) {
currentEditGenre = genre;
document.getElementById('taskModalTitle').textContent = `${genre} - タスク追加`;
document.getElementById('taskModal').style.display = 'flex';

// 日付の初期値設定
const today = new Date().toISOString().split('T')[0];
document.getElementById('taskStartDate').value = today;
document.getElementById('taskEndDate').value = today;
}

// タスク保存
function saveTask() {
const task = {
id: `${currentEditGenre}-${Date.now()}`,
genre: currentEditGenre,
title: document.getElementById('taskTitle').value,
type: document.getElementById('taskType').value,
startDate: document.getElementById('taskStartDate').value,
endDate: document.getElementById('taskEndDate').value,
estimatedPomodoros: parseInt(document.getElementById('taskPomodoros').value),
priority: document.getElementById('taskPriority').value,
details: document.getElementById('taskDetails').value,
progress: 0,
pomodoroSessions: 0,
completed: false
};

tasks[currentEditGenre].push(task);
renderTasks();
updateStats();
hideModal('taskModal');

// フォームリセット
document.getElementById('taskTitle').value = '';
document.getElementById('taskDetails').value = '';
}

// タスク削除
function deleteTask(taskId) {
if (confirm('このタスクを削除しますか？')) {
Object.keys(tasks).forEach(genre => {
tasks[genre] = tasks[genre].filter(task => task.id !== taskId);
});
renderTasks();
updateStats();
}
}

// タスク完了切り替え
function toggleTask(taskId) {
Object.keys(tasks).forEach(genre => {
tasks[genre] = tasks[genre].map(task => {
if (task.id === taskId) {
task.completed = !task.completed;
if (task.completed) {
task.progress = 100;
motivationLevel = Math.min(100, motivationLevel + 10);
updateMotivation();
}
}
return task;
});
});
renderTasks();
updateStats();
updateProgressSection();
}

// ポモドーロタイマー
function togglePomodoro() {
pomodoroActive = !pomodoroActive;
if (pomodoroActive) {
pomodoroInterval = setInterval(updatePomodoro, 1000);
} else {
clearInterval(pomodoroInterval);
}
}

function updatePomodoro() {
if (pomodoroTime > 0) {
pomodoroTime--;
const minutes = Math.floor(pomodoroTime / 60);
const seconds = pomodoroTime % 60;
document.getElementById('pomodoroTime').textContent =
`${minutes}:${seconds.toString().padStart(2, '0')}`;
} else {
completePomodoro();
}
}

function completePomodoro() {
pomodoroActive = false;
clearInterval(pomodoroInterval);
pomodoroTime = 25 * 60;

// 今日の進捗更新
const today = new Date().toISOString().split('T')[0];
dailyProgress[today] = (dailyProgress[today] || 0) + 1;

// 現在のタスクの進捗更新
if (currentTaskId) {
Object.keys(tasks).forEach(genre => {
tasks[genre] = tasks[genre].map(task => {
if (task.id === currentTaskId) {
task.pomodoroSessions++;
task.progress = Math.min(100, (task.pomodoroSessions / task.estimatedPomodoros) * 100);
}
return task;
});
});
}

motivationLevel = Math.min(100, motivationLevel + 5);
updateMotivation();
updateTodayProgress();
renderTasks();
updateStats();
updateProgressSection();

alert('🎉 ポモドーロ完了！5分休憩してください');
}

function startTaskPomodoro(taskId) {
currentTaskId = taskId;
if (!pomodoroActive) {
togglePomodoro();
}
}

// 今日の進捗更新
function updateTodayProgress() {
const today = new Date().toISOString().split('T')[0];
const todayCount = dailyProgress[today] || 0;

document.getElementById('todayCount').textContent = todayCount;

const dots = document.querySelectorAll('.pomodoro-dot');
dots.forEach((dot, index) => {
if (index < todayCount) {
dot.classList.add('filled');
} else {
dot.classList.remove('filled');
}
});
}

// カレンダー表示
function showCalendarModal() {
const calendar = document.getElementById('calendarContent');
const today = new Date();
const year = today.getFullYear();
const month = today.getMonth();
const firstDay = new Date(year, month, 1);
const lastDay = new Date(year, month + 1, 0);
const daysInMonth = lastDay.getDate();

let html = '<div class="calendar">';

// 曜日ヘッダー
const weekDays = ['日', '月', '火', '水', '木', '金', '土'];
weekDays.forEach(day => {
html += `<div style="font-weight: bold; text-align: center; padding: 5px;">${day}</div>`;
});

// 月初の空白
for (let i = 0; i < firstDay.getDay(); i++) {
html += '<div></div>';
}

// 日付
for (let day = 1; day <= daysInMonth; day++) {
const date = new Date(year, month, day);
const dateStr = date.toISOString().split('T')[0];
const pomodoros = dailyProgress[dateStr] || 0;
const isToday = day === today.getDate();

let emoji = '';
if (pomodoros >= 8) emoji = '🏆';
else if (pomodoros >= 4) emoji = '⭐';
else if (pomodoros > 0) emoji = '✓';

html += `
<div class="calendar-day ${isToday ? 'today' : ''}">
<div class="calendar-day-number">${day}</div>
${emoji ? `<div>${emoji}</div>` : ''}
${pomodoros > 0 ? `<div class="calendar-day-pomodoros">${pomodoros}🍅</div>` : ''}
</div>
`;
}

html += '</div>';
calendar.innerHTML = html;
document.getElementById('calendarModal').style.display = 'flex';
}

// モチベーション更新
function updateMotivation() {
document.getElementById('motivationBar').style.width = `${motivationLevel}%`;
let text = '';
if (motivationLevel >= 90) text = '🔥 絶好調！';
else if (motivationLevel >= 70) text = '⭐ いい感じ！';
else if (motivationLevel >= 50) text = '💖 その調子！';
else text = '☕ 休憩も大切';
document.getElementById('motivationText').textContent = `${text} ${motivationLevel}%`;
}

// 統計更新
function updateStats() {
let completed = 0;
let pomodoros = 0;
let words = 0;

Object.values(tasks).forEach(genreTasks => {
genreTasks.forEach(task => {
if (task.completed) completed++;
pomodoros += task.pomodoroSessions;
if (task.type === 'writing') {
words += Math.floor(task.progress * 720);
}
});
});

document.getElementById('completedCount').textContent = completed;
document.getElementById('pomodoroCount').textContent = pomodoros;
document.getElementById('wordCount').textContent = words.toLocaleString();
}

// AIアドバイス更新
function updateAIAdvice() {
const allTasks = Object.values(tasks).flat().filter(t => !t.completed);
const sortedTasks = allTasks.sort((a, b) => {
const scoreA = calculatePriority(a);
const scoreB = calculatePriority(b);
return scoreB - scoreA;
});

const advice = document.getElementById('aiAdvice');
if (sortedTasks.length > 0) {
advice.innerHTML = sortedTasks.slice(0, 3).map((task, index) =>
`<div style="padding: 5px 0;">
<strong>#${index + 1}</strong> ${task.title}
<span style="font-size: 12px; color: #666;">
(期限: ${new Date(task.endDate).toLocaleDateString('ja-JP')})
</span>
</div>`
).join('');
} else {
advice.innerHTML = 'すべてのタスクが完了しています！🎉';
}
}

function calculatePriority(task) {
const today = new Date();
const deadline = new Date(task.endDate);
const daysLeft = Math.ceil((deadline - today) / (1000 * 60 * 60 * 24));

let score = 0;
if (daysLeft < 0) score += 100;
else if (daysLeft <= 2) score += 80;
else if (daysLeft <= 5) score += 50;

if (task.priority === 'high') score += 40;
else if (task.priority === 'medium') score += 20;

return score;
}

// ジャンル選択
function selectGenre(genre) {
selectedGenre = genre;
document.querySelectorAll('.genre-tab').forEach(tab => {
tab.classList.remove('active');
if (tab.textContent === genre) {
tab.classList.add('active');
}
});
renderTasks();
}

// ジャンル追加モーダル
function showAddGenreModal() {
document.getElementById('genreModal').style.display = 'flex';
}

function hideModal(modalId) {
document.getElementById(modalId).style.display = 'none';
}

function addGenre() {
const input = document.getElementById('genreInput');
const genreName = input.value.trim();

if (genreName && !genres.includes(genreName)) {
genres.push(genreName);
tasks[genreName] = generateTasksForGenre(genreName);

// タブ追加
const tabsContainer = document.querySelector('.genre-tabs');
const newTab = document.createElement('div');
newTab.className = 'genre-tab';
newTab.textContent = genreName;
newTab.onclick = () => selectGenre(genreName);
tabsContainer.insertBefore(newTab, tabsContainer.lastElementChild);

renderTasks();
updateStats();
updateProgressSection();
motivationLevel = Math.min(100, motivationLevel + 10);
updateMotivation();
}

input.value = '';
hideModal('genreModal');
}

// 初期化実行
init();
</script>
```// ===== IndexedDB設定 =====
let db;
const DB_NAME = 'DreamNovelDB';
const DB_VERSION = 1;
const STORE_NAME = 'userData';

// IndexedDB初期化
function initDB() {
    return new Promise((resolve, reject) => {
        const request = indexedDB.open(DB_NAME, DB_VERSION);
        
        request.onerror = () => {
            console.error('IndexedDB開けませんでした');
            reject(request.error);
        };
        
        request.onsuccess = () => {
            db = request.result;
            console.log('IndexedDB接続成功');
            resolve(db);
        };
        
        request.onupgradeneeded = (event) => {
            db = event.target.result;
            
            // オブジェクトストアが存在しない場合は作成
            if (!db.objectStoreNames.contains(STORE_NAME)) {
                const objectStore = db.createObjectStore(STORE_NAME, { keyPath: 'id' });
                objectStore.createIndex('timestamp', 'timestamp', { unique: false });
                console.log('オブジェクトストア作成完了');
            }
        };
    });
}

// データ保存（自動保存）
async function saveToIndexedDB() {
    if (!db) {
        await initDB();
    }
    
    return new Promise((resolve, reject) => {
        const transaction = db.transaction([STORE_NAME], 'readwrite');
        const store = transaction.objectStore(STORE_NAME);
        
        const data = {
            id: 'mainData',
            tasks: tasks,
            genres: genres,
            dailyProgress: dailyProgress,
            selectedGenre: selectedGenre,
            motivationLevel: motivationLevel,
            timestamp: new Date().toISOString(),
            lastModified: Date.now()
        };
        
        const request = store.put(data);
        
        request.onsuccess = () => {
            console.log('データ保存成功:', new Date().toLocaleTimeString());
            resolve();
        };
        
        request.onerror = () => {
            console.error('データ保存失敗');
            reject(request.error);
        };
    });
}

// データ読み込み
async function loadFromIndexedDB() {
    if (!db) {
        await initDB();
    }
    
    return new Promise((resolve, reject) => {
        const transaction = db.transaction([STORE_NAME], 'readonly');
        const store = transaction.objectStore(STORE_NAME);
        const request = store.get('mainData');
        
        request.onsuccess = () => {
            if (request.result) {
                const data = request.result;
                tasks = data.tasks || {};
                genres = data.genres || ['TRICK', 'KILLERS'];
                dailyProgress = data.dailyProgress || {};
                selectedGenre = data.selectedGenre || '全体';
                motivationLevel = data.motivationLevel || 75;
                
                console.log('データ読み込み成功:', data.timestamp);
                resolve(data);
            } else {
                console.log('保存データなし - 初期データを使用');
                resolve(null);
            }
        };
        
        request.onerror = () => {
            console.error('データ読み込み失敗');
            reject(request.error);
        };
    });
}

// バックアップデータのエクスポート
function exportBackup() {
    const data = {
        tasks: tasks,
        genres: genres,
        dailyProgress: dailyProgress,
        selectedGenre: selectedGenre,
        motivationLevel: motivationLevel,
        exportDate: new Date().toISOString(),
        version: '1.0'
    };
    
    const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `dream-novel-backup-${new Date().toISOString().split('T')[0]}.json`;
    a.click();
    URL.revokeObjectURL(url);
    
    alert('バックアップファイルをダウンロードしました');
}

// バックアップデータのインポート
function importBackup() {
    const input = document.createElement('input');
    input.type = 'file';
    input.accept = '.json';
    
    input.onchange = async (e) => {
        const file = e.target.files[0];
        if (!file) return;
        
        const reader = new FileReader();
        reader.onload = async (event) => {
            try {
                const data = JSON.parse(event.target.result);
                
                // データを復元
                tasks = data.tasks || {};
                genres = data.genres || ['TRICK', 'KILLERS'];
                dailyProgress = data.dailyProgress || {};
                selectedGenre = data.selectedGenre || '全体';
                motivationLevel = data.motivationLevel || 75;
                
                // IndexedDBに保存
                await saveToIndexedDB();
                
                // UIを更新
                renderTasks();
                updateStats();
                updateMotivation();
                updateProgressSection();
                
                alert('データのインポートが完了しました！');
            } catch (error) {
                console.error('インポート失敗:', error);
                alert('ファイルの読み込みに失敗しました');
            }
        };
        
        reader.readAsText(file);
    };
    
    input.click();
}

// 自動保存（変更があった場合）
let saveTimeout;
function autoSave() {
    clearTimeout(saveTimeout);
    saveTimeout = setTimeout(() => {
        saveToIndexedDB().catch(console.error);
    }, 1000); // 1秒後に保存
}

// 既存の関数を修正 - データ変更時に自動保存を呼び出す
const originalToggleTask = toggleTask;
toggleTask = function(taskId) {
    originalToggleTask(taskId);
    autoSave();
};

const originalSaveTask = saveTask;
saveTask = function() {
    originalSaveTask();
    autoSave();
};

const originalDeleteTask = deleteTask;
deleteTask = function(taskId) {
    originalDeleteTask(taskId);
    autoSave();
};

const originalCompletePomodoro = completePomodoro;
completePomodoro = function() {
    originalCompletePomodoro();
    autoSave();
};

// 初期化関数を修正
async function init() {
    try {
        // IndexedDBから読み込み
        await loadFromIndexedDB();
        
        // データがない場合は初期データを生成
        if (Object.keys(tasks).length === 0) {
            generateInitialTasks();
        }
        
        // UI更新
        renderTasks();
        updateStats();
        updateAIAdvice();
        checkOverdueTasks();
        updateProgressSection();
        updateMotivation();
        updateTodayProgress();
        
    } catch (error) {
        console.error('初期化エラー:', error);
        // フォールバック: localStorage使用
        const saved = localStorage.getItem('dreamNovelData');
        if (saved) {
            const data = JSON.parse(saved);
            tasks = data.tasks || {};
            genres = data.genres || ['TRICK', 'KILLERS'];
            dailyProgress = data.dailyProgress || {};
        } else {
            generateInitialTasks();
        }
        renderTasks();
        updateStats();
    }
}

// ページ離脱時の保存
window.addEventListener('beforeunload', () => {
    // 同期的に保存（非推奨だが確実）
    const data = {
        tasks: tasks,
        genres: genres,
        dailyProgress: dailyProgress,
        selectedGenre: selectedGenre,
        motivationLevel: motivationLevel
    };
    localStorage.setItem('dreamNovelData', JSON.stringify(data));
});

// 定期的な自動保存（5分ごと）
setInterval(() => {
    saveToIndexedDB().catch(console.error);
}, 5 * 60 * 1000);

</body>
</html>

